// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package postgresqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	notificationservice "libdb.so/e2clicker/services/notification"
	userservice "libdb.so/e2clicker/services/user"
)

const createUser = `-- name: CreateUser :one
/*
 * User
 */
INSERT INTO users (secret, name)
  VALUES ($1, $2)
RETURNING secret, name, locale, registered_at, notification_preferences
`

type CreateUserParams struct {
	Secret userservice.Secret
	Name   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Secret, arg.Name)
	var i User
	err := row.Scan(
		&i.Secret,
		&i.Name,
		&i.Locale,
		&i.RegisteredAt,
		&i.NotificationPreferences,
	)
	return i, err
}

const deleteDosageSchedule = `-- name: DeleteDosageSchedule :exec
DELETE FROM dosage_schedule
WHERE user_secret = $1
`

func (q *Queries) DeleteDosageSchedule(ctx context.Context, userSecret userservice.Secret) error {
	_, err := q.db.Exec(ctx, deleteDosageSchedule, userSecret)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM user_sessions
WHERE user_secret = $1
  AND id = $2
`

type DeleteSessionParams struct {
	UserSecret userservice.Secret
	ID         int64
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSession, arg.UserSecret, arg.ID)
	return err
}

const deliveryMethod = `-- name: DeliveryMethod :one
SELECT id, units, name
FROM delivery_methods
WHERE name = $1
`

func (q *Queries) DeliveryMethod(ctx context.Context, name string) (DeliveryMethod, error) {
	row := q.db.QueryRow(ctx, deliveryMethod, name)
	var i DeliveryMethod
	err := row.Scan(&i.ID, &i.Units, &i.Name)
	return i, err
}

const deliveryMethods = `-- name: DeliveryMethods :many
/*
 * Delivery Method
 */
SELECT id, units, name
FROM delivery_methods
`

func (q *Queries) DeliveryMethods(ctx context.Context) ([]DeliveryMethod, error) {
	rows, err := q.db.Query(ctx, deliveryMethods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryMethod
	for rows.Next() {
		var i DeliveryMethod
		if err := rows.Scan(&i.ID, &i.Units, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dosageSchedule = `-- name: DosageSchedule :one
/*
 * Dosage and dosage-related
 */
SELECT user_secret, delivery_method, dose, interval, concurrence
FROM dosage_schedule
WHERE user_secret = $1
`

func (q *Queries) DosageSchedule(ctx context.Context, userSecret userservice.Secret) (DosageSchedule, error) {
	row := q.db.QueryRow(ctx, dosageSchedule, userSecret)
	var i DosageSchedule
	err := row.Scan(
		&i.UserSecret,
		&i.DeliveryMethod,
		&i.Dose,
		&i.Interval,
		&i.Concurrence,
	)
	return i, err
}

const doseHistory = `-- name: DoseHistory :many
SELECT dose_id, user_secret, delivery_method, dose, taken_at, taken_off_at
FROM dosage_history
WHERE user_secret = $1
  AND taken_at >= $2
  AND taken_at < $3
  -- order latest last
ORDER BY taken_at ASC
`

type DoseHistoryParams struct {
	UserSecret userservice.Secret
	Start      pgtype.Timestamptz
	End        pgtype.Timestamptz
}

func (q *Queries) DoseHistory(ctx context.Context, arg DoseHistoryParams) ([]DosageHistory, error) {
	rows, err := q.db.Query(ctx, doseHistory, arg.UserSecret, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DosageHistory
	for rows.Next() {
		var i DosageHistory
		if err := rows.Scan(
			&i.DoseID,
			&i.UserSecret,
			&i.DeliveryMethod,
			&i.Dose,
			&i.TakenAt,
			&i.TakenOffAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const editDose = `-- name: EditDose :execrows
UPDATE
  dosage_history
SET delivery_method = $3, dose = $4, taken_at = $5, taken_off_at = $6
WHERE user_secret = $2
  AND dose_id = $1
RETURNING dose_id, user_secret, delivery_method, dose, taken_at, taken_off_at
`

type EditDoseParams struct {
	DoseID         int64
	UserSecret     userservice.Secret
	DeliveryMethod pgtype.Text
	Dose           float32
	TakenAt        pgtype.Timestamptz
	TakenOffAt     pgtype.Timestamptz
}

func (q *Queries) EditDose(ctx context.Context, arg EditDoseParams) (int64, error) {
	result, err := q.db.Exec(ctx, editDose,
		arg.DoseID,
		arg.UserSecret,
		arg.DeliveryMethod,
		arg.Dose,
		arg.TakenAt,
		arg.TakenOffAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const forgetDoses = `-- name: ForgetDoses :execrows
DELETE FROM dosage_history
WHERE user_secret = $1
  AND dose_id = ANY ($2::bigint[])
`

type ForgetDosesParams struct {
	UserSecret userservice.Secret
	DoseIDs    []int64
}

func (q *Queries) ForgetDoses(ctx context.Context, arg ForgetDosesParams) (int64, error) {
	result, err := q.db.Exec(ctx, forgetDoses, arg.UserSecret, arg.DoseIDs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, user_secret, token, created_at, last_used, user_agent
FROM user_sessions
WHERE user_secret = $1
`

func (q *Queries) ListSessions(ctx context.Context, userSecret userservice.Secret) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, listSessions, userSecret)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserSecret,
			&i.Token,
			&i.CreatedAt,
			&i.LastUsed,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordDose = `-- name: RecordDose :one
INSERT INTO dosage_history (user_secret, taken_at, delivery_method, dose) (
  SELECT $1::usersecret, $2::timestamptz, delivery_method, dose
  FROM dosage_schedule
  WHERE dosage_schedule.user_secret = $1::usersecret)
RETURNING dosage_history.dose_id, dosage_history.user_secret, dosage_history.delivery_method, dosage_history.dose, dosage_history.taken_at, dosage_history.taken_off_at
`

type RecordDoseParams struct {
	UserSecret userservice.Secret
	TakenAt    pgtype.Timestamptz
}

func (q *Queries) RecordDose(ctx context.Context, arg RecordDoseParams) (DosageHistory, error) {
	row := q.db.QueryRow(ctx, recordDose, arg.UserSecret, arg.TakenAt)
	var i DosageHistory
	err := row.Scan(
		&i.DoseID,
		&i.UserSecret,
		&i.DeliveryMethod,
		&i.Dose,
		&i.TakenAt,
		&i.TakenOffAt,
	)
	return i, err
}

const registerSession = `-- name: RegisterSession :exec
/*                                                                                 
 * User Session                                                                    
 */
INSERT INTO user_sessions (user_secret, token, created_at, last_used, user_agent)
  VALUES ($1, $2, now(), now(), $3)
`

type RegisterSessionParams struct {
	UserSecret userservice.Secret
	Token      []byte
	UserAgent  pgtype.Text
}

func (q *Queries) RegisterSession(ctx context.Context, arg RegisterSessionParams) error {
	_, err := q.db.Exec(ctx, registerSession, arg.UserSecret, arg.Token, arg.UserAgent)
	return err
}

const setDosageSchedule = `-- name: SetDosageSchedule :exec
INSERT INTO dosage_schedule (user_secret, delivery_method, dose, interval, concurrence)
  VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (user_secret)
  DO UPDATE SET
    delivery_method = $2, dose = $3, interval = $4, concurrence = $5
`

type SetDosageScheduleParams struct {
	UserSecret     userservice.Secret
	DeliveryMethod pgtype.Text
	Dose           float32
	Interval       pgtype.Interval
	Concurrence    pgtype.Int2
}

func (q *Queries) SetDosageSchedule(ctx context.Context, arg SetDosageScheduleParams) error {
	_, err := q.db.Exec(ctx, setDosageSchedule,
		arg.UserSecret,
		arg.DeliveryMethod,
		arg.Dose,
		arg.Interval,
		arg.Concurrence,
	)
	return err
}

const setUserAvatar = `-- name: SetUserAvatar :exec
INSERT INTO user_avatars (user_secret, avatar_image, mime_type)
  VALUES ($1, $2, $3)
ON CONFLICT (user_secret)
  DO UPDATE SET
    avatar_image = $2, mime_type = $3
`

type SetUserAvatarParams struct {
	UserSecret  userservice.Secret
	AvatarImage []byte
	MIMEType    string
}

func (q *Queries) SetUserAvatar(ctx context.Context, arg SetUserAvatarParams) error {
	_, err := q.db.Exec(ctx, setUserAvatar, arg.UserSecret, arg.AvatarImage, arg.MIMEType)
	return err
}

const setUserNotificationPreferences = `-- name: SetUserNotificationPreferences :exec
UPDATE
  users
SET notification_preferences = $2
WHERE secret = $1
`

type SetUserNotificationPreferencesParams struct {
	Secret                  userservice.Secret
	NotificationPreferences *notificationservice.UserPreferences
}

func (q *Queries) SetUserNotificationPreferences(ctx context.Context, arg SetUserNotificationPreferencesParams) error {
	_, err := q.db.Exec(ctx, setUserNotificationPreferences, arg.Secret, arg.NotificationPreferences)
	return err
}

const updateUserLocale = `-- name: UpdateUserLocale :exec
UPDATE
  users
SET locale = $2
WHERE secret = $1
`

type UpdateUserLocaleParams struct {
	Secret userservice.Secret
	Locale userservice.Locale
}

func (q *Queries) UpdateUserLocale(ctx context.Context, arg UpdateUserLocaleParams) error {
	_, err := q.db.Exec(ctx, updateUserLocale, arg.Secret, arg.Locale)
	return err
}

const updateUserName = `-- name: UpdateUserName :exec
UPDATE
  users
SET name = $2
WHERE secret = $1
`

type UpdateUserNameParams struct {
	Secret userservice.Secret
	Name   string
}

func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) error {
	_, err := q.db.Exec(ctx, updateUserName, arg.Secret, arg.Name)
	return err
}

const user = `-- name: User :one
SELECT secret, name, locale, has_avatar
FROM users_with_avatar
WHERE secret = $1
`

func (q *Queries) User(ctx context.Context, secret userservice.Secret) (UsersWithAvatar, error) {
	row := q.db.QueryRow(ctx, user, secret)
	var i UsersWithAvatar
	err := row.Scan(
		&i.Secret,
		&i.Name,
		&i.Locale,
		&i.HasAvatar,
	)
	return i, err
}

const userAvatar = `-- name: UserAvatar :one
/*
 * User Avatar
 */
SELECT avatar_image, mime_type
FROM user_avatars
WHERE user_secret = $1
`

type UserAvatarRow struct {
	AvatarImage []byte
	MIMEType    string
}

func (q *Queries) UserAvatar(ctx context.Context, userSecret userservice.Secret) (UserAvatarRow, error) {
	row := q.db.QueryRow(ctx, userAvatar, userSecret)
	var i UserAvatarRow
	err := row.Scan(&i.AvatarImage, &i.MIMEType)
	return i, err
}

const userNotificationPreferences = `-- name: UserNotificationPreferences :one
/*
 * User Notifications
 */
SELECT notification_preferences
FROM users
WHERE secret = $1
`

func (q *Queries) UserNotificationPreferences(ctx context.Context, secret userservice.Secret) (*notificationservice.UserPreferences, error) {
	row := q.db.QueryRow(ctx, userNotificationPreferences, secret)
	var notification_preferences *notificationservice.UserPreferences
	err := row.Scan(&notification_preferences)
	return notification_preferences, err
}

const validateSession = `-- name: ValidateSession :one
UPDATE
  user_sessions
SET last_used = now()
WHERE token = $1
RETURNING id, user_secret, token, created_at, last_used, user_agent
`

func (q *Queries) ValidateSession(ctx context.Context, token []byte) (UserSession, error) {
	row := q.db.QueryRow(ctx, validateSession, token)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserSecret,
		&i.Token,
		&i.CreatedAt,
		&i.LastUsed,
		&i.UserAgent,
	)
	return i, err
}

const version = `-- name: Version :one
/*
 * Meta
 */
SELECT v
FROM meta
`

func (q *Queries) Version(ctx context.Context) (int16, error) {
	row := q.db.QueryRow(ctx, version)
	var v int16
	err := row.Scan(&v)
	return v, err
}
