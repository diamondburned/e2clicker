// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dosage.sql

package postgresqlc

import (
	"context"
	"iter"

	userservice "e2clicker.app/services/user"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteDosageSchedule = `-- name: DeleteDosageSchedule :exec
DELETE FROM dosage_schedule
WHERE user_secret = $1
`

func (q *Queries) DeleteDosageSchedule(ctx context.Context, userSecret userservice.Secret) error {
	_, err := q.db.Exec(ctx, deleteDosageSchedule, userSecret)
	return err
}

const dosageSchedule = `-- name: DosageSchedule :one
/*
 * Dosage and dosage-related
 */
SELECT user_secret, delivery_method, dose, interval, concurrence
FROM dosage_schedule
WHERE user_secret = $1
`

func (q *Queries) DosageSchedule(ctx context.Context, userSecret userservice.Secret) (DosageSchedule, error) {
	row := q.db.QueryRow(ctx, dosageSchedule, userSecret)
	var i DosageSchedule
	err := row.Scan(
		&i.UserSecret,
		&i.DeliveryMethod,
		&i.Dose,
		&i.Interval,
		&i.Concurrence,
	)
	return i, err
}

const doseHistory = `-- name: DoseHistory :iter
SELECT user_secret, delivery_method, dose, taken_at, taken_off_at, comment
FROM dosage_history
WHERE user_secret = $1
  AND taken_at >= $2
  AND taken_at < $3
  -- order latest last
ORDER BY taken_at ASC
`

type DoseHistoryParams struct {
	UserSecret userservice.Secret
	Start      pgtype.Timestamptz
	End        pgtype.Timestamptz
}

func (q *Queries) DoseHistory(ctx context.Context, arg DoseHistoryParams) DoseHistoryRows {
	rows, err := q.db.Query(ctx, doseHistory, arg.UserSecret, arg.Start, arg.End)
	if err != nil {
		return DoseHistoryRows{err: err}
	}
	return DoseHistoryRows{rows: rows}
}

type DoseHistoryRows struct {
	rows pgx.Rows
	err  error
}

func (r *DoseHistoryRows) Iterate() iter.Seq[DosageHistory] {
	if r.rows == nil {
		return func(yield func(DosageHistory) bool) {}
	}

	return func(yield func(DosageHistory) bool) {
		defer r.rows.Close()

		for r.rows.Next() {
			var i DosageHistory
			err := r.rows.Scan(
				&i.UserSecret,
				&i.DeliveryMethod,
				&i.Dose,
				&i.TakenAt,
				&i.TakenOffAt,
				&i.Comment,
			)
			if err != nil {
				r.err = err
				return
			}

			if !yield(i) {
				return
			}
		}
	}
}

func (r *DoseHistoryRows) Close() {
	r.rows.Close()
}

func (r *DoseHistoryRows) Err() error {
	if r.err != nil {
		return r.err
	}
	return r.rows.Err()
}

const editDose = `-- name: EditDose :execrows
UPDATE
  dosage_history
SET delivery_method = $1, dose = $2, taken_at = $3, taken_off_at = $4
WHERE user_secret = $5
  AND taken_at = $6
`

type EditDoseParams struct {
	DeliveryMethod pgtype.Text
	Dose           float32
	TakenAt        pgtype.Timestamptz
	TakenOffAt     pgtype.Timestamptz
	UserSecret     userservice.Secret
	OldTakenAt     pgtype.Timestamptz
}

func (q *Queries) EditDose(ctx context.Context, arg EditDoseParams) (int64, error) {
	result, err := q.db.Exec(ctx, editDose,
		arg.DeliveryMethod,
		arg.Dose,
		arg.TakenAt,
		arg.TakenOffAt,
		arg.UserSecret,
		arg.OldTakenAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const forgetDoses = `-- name: ForgetDoses :execrows
DELETE FROM dosage_history
WHERE user_secret = $1
  AND taken_at = ANY ($2::timestamp[])
`

type ForgetDosesParams struct {
	UserSecret userservice.Secret
	TakenAt    []pgtype.Timestamp
}

func (q *Queries) ForgetDoses(ctx context.Context, arg ForgetDosesParams) (int64, error) {
	result, err := q.db.Exec(ctx, forgetDoses, arg.UserSecret, arg.TakenAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const recordDose = `-- name: RecordDose :exec
INSERT INTO dosage_history (user_secret, delivery_method, dose, taken_at, taken_off_at)
  VALUES ($1, $2, $3, $4, $5)
`

type RecordDoseParams struct {
	UserSecret     userservice.Secret
	DeliveryMethod pgtype.Text
	Dose           float32
	TakenAt        pgtype.Timestamptz
	TakenOffAt     pgtype.Timestamptz
}

func (q *Queries) RecordDose(ctx context.Context, arg RecordDoseParams) error {
	_, err := q.db.Exec(ctx, recordDose,
		arg.UserSecret,
		arg.DeliveryMethod,
		arg.Dose,
		arg.TakenAt,
		arg.TakenOffAt,
	)
	return err
}

const recordRemindedDoseAttempt = `-- name: RecordRemindedDoseAttempt :exec
INSERT INTO notification_history (user_secret, sent_at, supposed_entity_time, error_reason, errored)
  VALUES ($1, $2, $3, $4, $4 IS NOT NULL)
`

type RecordRemindedDoseAttemptParams struct {
	UserSecret         userservice.Secret
	SentAt             pgtype.Timestamptz
	SupposedEntityTime pgtype.Timestamptz
	ErrorReason        pgtype.Text
}

func (q *Queries) RecordRemindedDoseAttempt(ctx context.Context, arg RecordRemindedDoseAttemptParams) error {
	_, err := q.db.Exec(ctx, recordRemindedDoseAttempt,
		arg.UserSecret,
		arg.SentAt,
		arg.SupposedEntityTime,
		arg.ErrorReason,
	)
	return err
}

const setDosageSchedule = `-- name: SetDosageSchedule :exec
INSERT INTO dosage_schedule (user_secret, delivery_method, dose, interval, concurrence)
  VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (user_secret)
  DO UPDATE SET
    delivery_method = $2, dose = $3, interval = $4, concurrence = $5
`

type SetDosageScheduleParams struct {
	UserSecret     userservice.Secret
	DeliveryMethod pgtype.Text
	Dose           float32
	Interval       pgtype.Interval
	Concurrence    pgtype.Int2
}

func (q *Queries) SetDosageSchedule(ctx context.Context, arg SetDosageScheduleParams) error {
	_, err := q.db.Exec(ctx, setDosageSchedule,
		arg.UserSecret,
		arg.DeliveryMethod,
		arg.Dose,
		arg.Interval,
		arg.Concurrence,
	)
	return err
}

const upcomingDosageReminders = `-- name: UpcomingDosageReminders :iter
SELECT DISTINCT ON (users.secret)
  users.secret AS user_secret, users.name AS user_name, dosage_schedule.user_secret, dosage_schedule.delivery_method, dosage_schedule.dose, dosage_schedule.interval, dosage_schedule.concurrence,
    dosage_history.user_secret, dosage_history.delivery_method, dosage_history.dose, dosage_history.taken_at, dosage_history.taken_off_at, dosage_history.comment, -- 
  (
    SELECT supposed_entity_time
    FROM notification_history
    WHERE user_secret = users.secret ORDER BY supposed_entity_time DESC LIMIT 1) AS last_notification_time
FROM users
  INNER JOIN dosage_schedule ON users.secret = dosage_schedule.user_secret
  INNER JOIN dosage_history ON users.secret = dosage_history.user_secret
ORDER BY users.secret, dosage_history.taken_at DESC
`

type UpcomingDosageRemindersRow struct {
	UserSecret           userservice.Secret
	UserName             string
	DosageSchedule       DosageSchedule
	DosageHistory        DosageHistory
	LastNotificationTime pgtype.Timestamptz
}

func (q *Queries) UpcomingDosageReminders(ctx context.Context) UpcomingDosageRemindersRows {
	rows, err := q.db.Query(ctx, upcomingDosageReminders)
	if err != nil {
		return UpcomingDosageRemindersRows{err: err}
	}
	return UpcomingDosageRemindersRows{rows: rows}
}

type UpcomingDosageRemindersRows struct {
	rows pgx.Rows
	err  error
}

func (r *UpcomingDosageRemindersRows) Iterate() iter.Seq[UpcomingDosageRemindersRow] {
	if r.rows == nil {
		return func(yield func(UpcomingDosageRemindersRow) bool) {}
	}

	return func(yield func(UpcomingDosageRemindersRow) bool) {
		defer r.rows.Close()

		for r.rows.Next() {
			var i UpcomingDosageRemindersRow
			err := r.rows.Scan(
				&i.UserSecret,
				&i.UserName,
				&i.DosageSchedule.UserSecret,
				&i.DosageSchedule.DeliveryMethod,
				&i.DosageSchedule.Dose,
				&i.DosageSchedule.Interval,
				&i.DosageSchedule.Concurrence,
				&i.DosageHistory.UserSecret,
				&i.DosageHistory.DeliveryMethod,
				&i.DosageHistory.Dose,
				&i.DosageHistory.TakenAt,
				&i.DosageHistory.TakenOffAt,
				&i.DosageHistory.Comment,
				&i.LastNotificationTime,
			)
			if err != nil {
				r.err = err
				return
			}

			if !yield(i) {
				return
			}
		}
	}
}

func (r *UpcomingDosageRemindersRows) Close() {
	r.rows.Close()
}

func (r *UpcomingDosageRemindersRows) Err() error {
	if r.err != nil {
		return r.err
	}
	return r.rows.Err()
}
