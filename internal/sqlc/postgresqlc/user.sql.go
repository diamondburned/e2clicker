// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package postgresqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	notificationservice "libdb.so/e2clicker/services/notification"
	userservice "libdb.so/e2clicker/services/user"
)

const createUser = `-- name: CreateUser :one
/*
 * User
 */
INSERT INTO users (secret, name)
  VALUES ($1, $2)
RETURNING secret, name, locale, registered_at, notification_preferences
`

type CreateUserParams struct {
	Secret userservice.Secret
	Name   string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Secret, arg.Name)
	var i User
	err := row.Scan(
		&i.Secret,
		&i.Name,
		&i.Locale,
		&i.RegisteredAt,
		&i.NotificationPreferences,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM user_sessions
WHERE user_secret = $1
  AND id = $2
`

type DeleteSessionParams struct {
	UserSecret userservice.Secret
	ID         int64
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSession, arg.UserSecret, arg.ID)
	return err
}

const listSessions = `-- name: ListSessions :many
SELECT id, user_secret, token, created_at, last_used, user_agent
FROM user_sessions
WHERE user_secret = $1
`

func (q *Queries) ListSessions(ctx context.Context, userSecret userservice.Secret) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, listSessions, userSecret)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserSecret,
			&i.Token,
			&i.CreatedAt,
			&i.LastUsed,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerSession = `-- name: RegisterSession :exec
/*                                                                                 
 * User Session                                                                    
 */
INSERT INTO user_sessions (user_secret, token, created_at, last_used, user_agent)
  VALUES ($1, $2, now(), now(), $3)
`

type RegisterSessionParams struct {
	UserSecret userservice.Secret
	Token      []byte
	UserAgent  pgtype.Text
}

func (q *Queries) RegisterSession(ctx context.Context, arg RegisterSessionParams) error {
	_, err := q.db.Exec(ctx, registerSession, arg.UserSecret, arg.Token, arg.UserAgent)
	return err
}

const setUserAvatar = `-- name: SetUserAvatar :exec
INSERT INTO user_avatars (user_secret, avatar_image, mime_type)
  VALUES ($1, $2, $3)
ON CONFLICT (user_secret)
  DO UPDATE SET
    avatar_image = $2, mime_type = $3
`

type SetUserAvatarParams struct {
	UserSecret  userservice.Secret
	AvatarImage []byte
	MIMEType    string
}

func (q *Queries) SetUserAvatar(ctx context.Context, arg SetUserAvatarParams) error {
	_, err := q.db.Exec(ctx, setUserAvatar, arg.UserSecret, arg.AvatarImage, arg.MIMEType)
	return err
}

const setUserNotificationPreferences = `-- name: SetUserNotificationPreferences :exec
UPDATE
  users
SET notification_preferences = $2::jsonb
WHERE secret = $1
`

type SetUserNotificationPreferencesParams struct {
	Secret  userservice.Secret
	Column2 []byte
}

func (q *Queries) SetUserNotificationPreferences(ctx context.Context, arg SetUserNotificationPreferencesParams) error {
	_, err := q.db.Exec(ctx, setUserNotificationPreferences, arg.Secret, arg.Column2)
	return err
}

const updateUserLocale = `-- name: UpdateUserLocale :exec
UPDATE
  users
SET locale = $2
WHERE secret = $1
`

type UpdateUserLocaleParams struct {
	Secret userservice.Secret
	Locale userservice.Locale
}

func (q *Queries) UpdateUserLocale(ctx context.Context, arg UpdateUserLocaleParams) error {
	_, err := q.db.Exec(ctx, updateUserLocale, arg.Secret, arg.Locale)
	return err
}

const updateUserName = `-- name: UpdateUserName :exec
UPDATE
  users
SET name = $2
WHERE secret = $1
`

type UpdateUserNameParams struct {
	Secret userservice.Secret
	Name   string
}

func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) error {
	_, err := q.db.Exec(ctx, updateUserName, arg.Secret, arg.Name)
	return err
}

const user = `-- name: User :one
SELECT secret, name, locale, has_avatar
FROM users_with_avatar
WHERE secret = $1
`

func (q *Queries) User(ctx context.Context, secret userservice.Secret) (UsersWithAvatar, error) {
	row := q.db.QueryRow(ctx, user, secret)
	var i UsersWithAvatar
	err := row.Scan(
		&i.Secret,
		&i.Name,
		&i.Locale,
		&i.HasAvatar,
	)
	return i, err
}

const userAvatar = `-- name: UserAvatar :one
/*
 * User Avatar
 */
SELECT avatar_image, mime_type
FROM user_avatars
WHERE user_secret = $1
`

type UserAvatarRow struct {
	AvatarImage []byte
	MIMEType    string
}

func (q *Queries) UserAvatar(ctx context.Context, userSecret userservice.Secret) (UserAvatarRow, error) {
	row := q.db.QueryRow(ctx, userAvatar, userSecret)
	var i UserAvatarRow
	err := row.Scan(&i.AvatarImage, &i.MIMEType)
	return i, err
}

const userNotificationPreferences = `-- name: UserNotificationPreferences :one
/*
 * User Notifications
 */
SELECT notification_preferences
FROM users
WHERE secret = $1
`

func (q *Queries) UserNotificationPreferences(ctx context.Context, secret userservice.Secret) (notificationservice.UserPreferences, error) {
	row := q.db.QueryRow(ctx, userNotificationPreferences, secret)
	var notification_preferences notificationservice.UserPreferences
	err := row.Scan(&notification_preferences)
	return notification_preferences, err
}

const validateSession = `-- name: ValidateSession :one
UPDATE
  user_sessions
SET last_used = now()
WHERE token = $1
RETURNING id, user_secret, token, created_at, last_used, user_agent
`

func (q *Queries) ValidateSession(ctx context.Context, token []byte) (UserSession, error) {
	row := q.db.QueryRow(ctx, validateSession, token)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserSecret,
		&i.Token,
		&i.CreatedAt,
		&i.LastUsed,
		&i.UserAgent,
	)
	return i, err
}
