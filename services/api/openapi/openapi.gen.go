//go:build go1.22

// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version (devel) DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	"libdb.so/e2clicker/services/user"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for NotificationType.
const (
	AccountNotice   NotificationType = "account_notice"
	Reminder        NotificationType = "reminder"
	WebPushExpiring NotificationType = "web_push_expiring"
)

// PushDeviceID A short ID associated with the device that the push subscription is for This is used to identify the device when updating its push subscription later on.
// Realistically, this will be handled as an opaque random string generated on the device side, so the server has no way to correlate  it with any fingerprinting.
// The recommended way to generate this string in JavaScript is:
// ```js crypto.randomUUID().slice(0, 8) ```
type PushDeviceID = string

// DeliveryMethod defines model for DeliveryMethod.
type DeliveryMethod struct {
	// ID A short string representing the delivery method. This is what goes into the DeliveryMethod fields.
	ID string `json:"id"`

	// Units The units of the delivery method.
	Units string `json:"units"`

	// Name The full name of the delivery method.
	Name string `json:"name"`
}

// Dosage defines model for Dosage.
type Dosage struct {
	// DeliveryMethod The delivery method to use.
	DeliveryMethod string `json:"deliveryMethod"`

	// Dose The dosage amount.
	Dose float32 `json:"dose"`

	// Interval The interval between doses in days.
	Interval float64 `json:"interval"`

	// Concurrence The number of estrogen patches on the body at once. Only relevant if delivery method is patch.
	Concurrence *int `json:"concurrence,omitempty"`
}

// DosageHistory defines model for DosageHistory.
type DosageHistory = []DosageObservation

// DosageObservation defines model for DosageObservation.
type DosageObservation struct {
	// ID The unique identifier for the observation.
	ID int64 `json:"id"`

	// DeliveryMethod The delivery method used.
	DeliveryMethod string `json:"deliveryMethod"`

	// Dose The dosage amount.
	Dose float32 `json:"dose"`

	// TakenAt The time the dosage was taken.
	TakenAt time.Time `json:"takenAt"`

	// TakenOffAt The time the dosage was taken off. This is only relevant for patch delivery methods.
	TakenOffAt *time.Time `json:"takenOffAt,omitempty"`

	// Comment A comment about the dosage, if any.
	Comment *string `json:"comment,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Details Additional details about the error
	Details *interface{} `json:"details,omitempty"`

	// Internal Whether the error is internal
	Internal *bool `json:"internal,omitempty"`

	// InternalCode An internal code for the error (useless for clients)
	InternalCode *string `json:"internalCode,omitempty"`

	// Message A message describing the error
	Message string `json:"message"`
}

// Locale A locale identifier.
type Locale = user.Locale

// Notification defines model for Notification.
type Notification struct {
	// Type The type of notification.
	Type NotificationType `json:"type"`

	// Message The message of the notification.
	Message NotificationMessage `json:"message"`

	// Username The username of the user to send the notification to.
	Username string `json:"username"`
}

// NotificationType The type of notification.
type NotificationType string

// NotificationMessage The message of the notification. This is derived from the notification type but can be overridden by the user.
type NotificationMessage struct {
	// Title The title of the notification.
	Title string `json:"title"`

	// Message The message of the notification.
	Message string `json:"message"`
}

// PushInfo This is returned by the server and contains information that the client would need to subscribe to push notifications.
type PushInfo struct {
	// ApplicationServerKey A Base64-encoded string or ArrayBuffer containing an ECDSA P-256 public key that the push server will use to authenticate your application server. If specified, all messages from your application server must use the VAPID authentication scheme, and include a JWT signed with the corresponding private key. This key IS NOT the same ECDH key that you use to encrypt the data. For more information, see "Using VAPID with WebPush".
	ApplicationServerKey string `json:"applicationServerKey"`
}

// PushSubscription The configuration for a push notification subscription.
// This is the object that is returned by calling PushSubscription.toJSON(). More information can be found at: https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription/toJSON
type PushSubscription struct {
	// DeviceID A short ID associated with the device that the push subscription is for This is used to identify the device when updating its push subscription later on.
	// Realistically, this will be handled as an opaque random string generated on the device side, so the server has no way to correlate  it with any fingerprinting.
	// The recommended way to generate this string in JavaScript is:
	// ```js crypto.randomUUID().slice(0, 8) ```
	DeviceID PushDeviceID `json:"deviceID"`

	// Endpoint The endpoint to send the notification to.
	Endpoint string `json:"endpoint"`

	// ExpirationTime The time at which the subscription expires. This is the time when the subscription will be automatically deleted by the browser.
	ExpirationTime *time.Time `json:"expirationTime,omitempty"`

	// Keys The VAPID keys to encrypt the push notification.
	Keys struct {
		// P256Dh An Elliptic curve Diffie–Hellman public key on the P-256 curve (that is, the NIST secp256r1 elliptic curve). The resulting key is an uncompressed point in ANSI X9.62 format.
		P256Dh string `json:"p256dh"`

		// Auth An authentication secret, as described in Message Encryption for Web Push.
		Auth string `json:"auth"`
	} `json:"keys"`
}

// ReturnedNotificationMethods defines model for ReturnedNotificationMethods.
type ReturnedNotificationMethods struct {
	WebPush *[]ReturnedPushSubscription `json:"webPush,omitempty"`
}

// ReturnedPushSubscription Similar to a [PushSubscription], but specifically for returning to the user. This type contains no secrets.
type ReturnedPushSubscription struct {
	DeviceID PushDeviceID `json:"deviceID"`
	Keys     struct {
		// P256Dh An Elliptic curve Diffie–Hellman public key on the P-256 curve (that is, the NIST secp256r1 elliptic curve). The resulting key is an uncompressed point in ANSI X9.62 format.
		P256Dh string `json:"p256dh"`
	} `json:"keys"`

	// ExpirationTime The time at which the subscription expires. This is the time when the subscription will be automatically deleted by the browser.
	ExpirationTime *time.Time `json:"expirationTime,omitempty"`
}

// Session A session for a user.
type Session struct {
	// ID The session identifier
	ID int64 `json:"id"`

	// CreatedAt The time the session was created
	CreatedAt time.Time `json:"createdAt"`

	// LastUsed The last time the session was used
	LastUsed time.Time `json:"lastUsed"`

	// ExpiresAt The time the session expires, or null if it never expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

// User A user of the system.
type User struct {
	// Name The user's name
	Name string `json:"name"`

	// Locale A locale identifier.
	Locale Locale `json:"locale"`

	// HasAvatar Whether the user has an avatar.
	HasAvatar bool `json:"hasAvatar"`
}

// UserSecret A secret and unique user identifier. This secret is generated once and never changes. It is used to both authenticate and identify a user, so it should be kept secret.
type UserSecret = user.Secret

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = Error

// AuthJSONBody defines parameters for Auth.
type AuthJSONBody struct {
	// Secret A secret and unique user identifier. This secret is generated once and never changes. It is used to both authenticate and identify a user, so it should be kept secret.
	Secret UserSecret `json:"secret"`
}

// AuthParams defines parameters for Auth.
type AuthParams struct {
	// UserAgent The user agent of the client making the request.
	UserAgent *string `json:"User-Agent,omitempty"`
}

// DosageParams defines parameters for Dosage.
type DosageParams struct {
	HistoryStart *time.Time `form:"historyStart,omitempty" json:"historyStart,omitempty"`
	HistoryEnd   *time.Time `form:"historyEnd,omitempty" json:"historyEnd,omitempty"`
}

// ForgetDosesParams defines parameters for ForgetDoses.
type ForgetDosesParams struct {
	DoseIds []int64 `form:"dose_ids" json:"dose_ids"`
}

// RecordDoseJSONBody defines parameters for RecordDose.
type RecordDoseJSONBody struct {
	// TakenAt The time the dosage was taken.
	TakenAt time.Time `json:"takenAt"`
}

// EditDoseJSONBody defines parameters for EditDose.
type EditDoseJSONBody = DosageObservation

// DeleteUserSessionParams defines parameters for DeleteUserSession.
type DeleteUserSessionParams struct {
	ID int64 `form:"id" json:"id"`
}

// RegisterJSONBody defines parameters for Register.
type RegisterJSONBody struct {
	// Name The name to register with
	Name string `json:"name"`
}

// AuthJSONRequestBody defines body for Auth for application/json ContentType.
type AuthJSONRequestBody AuthJSONBody

// SetDosageJSONRequestBody defines body for SetDosage for application/json ContentType.
type SetDosageJSONRequestBody = Dosage

// RecordDoseJSONRequestBody defines body for RecordDose for application/json ContentType.
type RecordDoseJSONRequestBody RecordDoseJSONBody

// EditDoseJSONRequestBody defines body for EditDose for application/json ContentType.
type EditDoseJSONRequestBody = EditDoseJSONBody

// UserSubscribePushJSONRequestBody defines body for UserSubscribePush for application/json ContentType.
type UserSubscribePushJSONRequestBody = PushSubscription

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody RegisterJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate a user and obtain a session
	// (POST /auth)
	Auth(w http.ResponseWriter, r *http.Request, params AuthParams)
	// List all available delivery methods
	// (GET /deliverymethods)
	DeliveryMethods(w http.ResponseWriter, r *http.Request)
	// Clear the user's dosage schedule
	// (DELETE /dosage)
	ClearDosage(w http.ResponseWriter, r *http.Request)
	// Get the user's dosage and optionally their history
	// (GET /dosage)
	Dosage(w http.ResponseWriter, r *http.Request, params DosageParams)
	// Set the user's dosage
	// (PUT /dosage)
	SetDosage(w http.ResponseWriter, r *http.Request)
	// Delete multiple dosages from the user's history
	// (DELETE /dosage/dose)
	ForgetDoses(w http.ResponseWriter, r *http.Request, params ForgetDosesParams)
	// Record a new dosage to the user's history
	// (POST /dosage/dose)
	RecordDose(w http.ResponseWriter, r *http.Request)
	// Update a dosage in the user's history
	// (PUT /dosage/dose)
	EditDose(w http.ResponseWriter, r *http.Request)
	// Get the current user
	// (GET /me)
	CurrentUser(w http.ResponseWriter, r *http.Request)
	// Get the current user's avatar
	// (GET /me/avatar)
	CurrentUserAvatar(w http.ResponseWriter, r *http.Request)
	// Set the current user's avatar
	// (PUT /me/avatar)
	SetCurrentUserAvatar(w http.ResponseWriter, r *http.Request)
	// Get the current user's secret
	// (GET /me/secret)
	CurrentUserSecret(w http.ResponseWriter, r *http.Request)
	// Delete one of the current user's sessions
	// (DELETE /me/sessions)
	DeleteUserSession(w http.ResponseWriter, r *http.Request, params DeleteUserSessionParams)
	// List the current user's sessions
	// (GET /me/sessions)
	CurrentUserSessions(w http.ResponseWriter, r *http.Request)
	// Get the user's notification methods
	// (GET /notifications/methods)
	UserNotificationMethods(w http.ResponseWriter, r *http.Request)
	// Create or update a push subscription
	// (PUT /notifications/methods/push)
	UserSubscribePush(w http.ResponseWriter, r *http.Request)
	// Unsubscribe from push notifications
	// (DELETE /notifications/methods/push/{deviceID})
	UserUnsubscribePush(w http.ResponseWriter, r *http.Request, deviceID PushDeviceID)
	// Get the user's push notification subscription
	// (GET /notifications/methods/push/{deviceID})
	UserPushSubscription(w http.ResponseWriter, r *http.Request, deviceID PushDeviceID)
	// Get the server's push notification information
	// (GET /pushinfo)
	WebPushInfo(w http.ResponseWriter, r *http.Request)
	// Register a new account
	// (POST /register)
	Register(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Auth operation middleware
func (siw *ServerInterfaceWrapper) Auth(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthParams

	headers := r.Header

	// ------------- Optional header parameter "User-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("User-Agent")]; found {
		var UserAgent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "User-Agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "User-Agent", valueList[0], &UserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "User-Agent", Err: err})
			return
		}

		params.UserAgent = &UserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Auth(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeliveryMethods operation middleware
func (siw *ServerInterfaceWrapper) DeliveryMethods(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeliveryMethods(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClearDosage operation middleware
func (siw *ServerInterfaceWrapper) ClearDosage(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClearDosage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Dosage operation middleware
func (siw *ServerInterfaceWrapper) Dosage(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DosageParams

	// ------------- Optional query parameter "historyStart" -------------

	err = runtime.BindQueryParameter("form", true, false, "historyStart", r.URL.Query(), &params.HistoryStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "historyStart", Err: err})
		return
	}

	// ------------- Optional query parameter "historyEnd" -------------

	err = runtime.BindQueryParameter("form", true, false, "historyEnd", r.URL.Query(), &params.HistoryEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "historyEnd", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Dosage(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetDosage operation middleware
func (siw *ServerInterfaceWrapper) SetDosage(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetDosage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ForgetDoses operation middleware
func (siw *ServerInterfaceWrapper) ForgetDoses(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ForgetDosesParams

	// ------------- Required query parameter "dose_ids" -------------

	if paramValue := r.URL.Query().Get("dose_ids"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "dose_ids"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "dose_ids", r.URL.Query(), &params.DoseIds)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dose_ids", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ForgetDoses(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecordDose operation middleware
func (siw *ServerInterfaceWrapper) RecordDose(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecordDose(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EditDose operation middleware
func (siw *ServerInterfaceWrapper) EditDose(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditDose(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CurrentUser operation middleware
func (siw *ServerInterfaceWrapper) CurrentUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CurrentUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CurrentUserAvatar operation middleware
func (siw *ServerInterfaceWrapper) CurrentUserAvatar(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CurrentUserAvatar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetCurrentUserAvatar operation middleware
func (siw *ServerInterfaceWrapper) SetCurrentUserAvatar(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetCurrentUserAvatar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CurrentUserSecret operation middleware
func (siw *ServerInterfaceWrapper) CurrentUserSecret(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CurrentUserSecret(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserSession operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserSession(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserSessionParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.ID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserSession(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CurrentUserSessions operation middleware
func (siw *ServerInterfaceWrapper) CurrentUserSessions(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CurrentUserSessions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UserNotificationMethods operation middleware
func (siw *ServerInterfaceWrapper) UserNotificationMethods(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserNotificationMethods(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UserSubscribePush operation middleware
func (siw *ServerInterfaceWrapper) UserSubscribePush(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserSubscribePush(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UserUnsubscribePush operation middleware
func (siw *ServerInterfaceWrapper) UserUnsubscribePush(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceID" -------------
	var deviceID PushDeviceID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceID", r.PathValue("deviceID"), &deviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserUnsubscribePush(w, r, deviceID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UserPushSubscription operation middleware
func (siw *ServerInterfaceWrapper) UserPushSubscription(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceID" -------------
	var deviceID PushDeviceID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceID", r.PathValue("deviceID"), &deviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserPushSubscription(w, r, deviceID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WebPushInfo operation middleware
func (siw *ServerInterfaceWrapper) WebPushInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WebPushInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Register(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/auth", wrapper.Auth)
	m.HandleFunc("GET "+options.BaseURL+"/deliverymethods", wrapper.DeliveryMethods)
	m.HandleFunc("DELETE "+options.BaseURL+"/dosage", wrapper.ClearDosage)
	m.HandleFunc("GET "+options.BaseURL+"/dosage", wrapper.Dosage)
	m.HandleFunc("PUT "+options.BaseURL+"/dosage", wrapper.SetDosage)
	m.HandleFunc("DELETE "+options.BaseURL+"/dosage/dose", wrapper.ForgetDoses)
	m.HandleFunc("POST "+options.BaseURL+"/dosage/dose", wrapper.RecordDose)
	m.HandleFunc("PUT "+options.BaseURL+"/dosage/dose", wrapper.EditDose)
	m.HandleFunc("GET "+options.BaseURL+"/me", wrapper.CurrentUser)
	m.HandleFunc("GET "+options.BaseURL+"/me/avatar", wrapper.CurrentUserAvatar)
	m.HandleFunc("PUT "+options.BaseURL+"/me/avatar", wrapper.SetCurrentUserAvatar)
	m.HandleFunc("GET "+options.BaseURL+"/me/secret", wrapper.CurrentUserSecret)
	m.HandleFunc("DELETE "+options.BaseURL+"/me/sessions", wrapper.DeleteUserSession)
	m.HandleFunc("GET "+options.BaseURL+"/me/sessions", wrapper.CurrentUserSessions)
	m.HandleFunc("GET "+options.BaseURL+"/notifications/methods", wrapper.UserNotificationMethods)
	m.HandleFunc("PUT "+options.BaseURL+"/notifications/methods/push", wrapper.UserSubscribePush)
	m.HandleFunc("DELETE "+options.BaseURL+"/notifications/methods/push/{deviceID}", wrapper.UserUnsubscribePush)
	m.HandleFunc("GET "+options.BaseURL+"/notifications/methods/push/{deviceID}", wrapper.UserPushSubscription)
	m.HandleFunc("GET "+options.BaseURL+"/pushinfo", wrapper.WebPushInfo)
	m.HandleFunc("POST "+options.BaseURL+"/register", wrapper.Register)

	return m
}

type ErrorResponseJSONResponse Error

type AuthRequestObject struct {
	Params AuthParams
	Body   *AuthJSONRequestBody
}

type AuthResponseObject interface {
	VisitAuthResponse(w http.ResponseWriter) error
}

type Auth200JSONResponse struct {
	// Token The session token
	Token string `json:"token"`
}

func (response Auth200JSONResponse) VisitAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AuthdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response AuthdefaultJSONResponse) VisitAuthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeliveryMethodsRequestObject struct {
}

type DeliveryMethodsResponseObject interface {
	VisitDeliveryMethodsResponse(w http.ResponseWriter) error
}

type DeliveryMethods200JSONResponse []DeliveryMethod

func (response DeliveryMethods200JSONResponse) VisitDeliveryMethodsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeliveryMethodsdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response DeliveryMethodsdefaultJSONResponse) VisitDeliveryMethodsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ClearDosageRequestObject struct {
}

type ClearDosageResponseObject interface {
	VisitClearDosageResponse(w http.ResponseWriter) error
}

type ClearDosage204Response struct {
}

func (response ClearDosage204Response) VisitClearDosageResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ClearDosagedefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response ClearDosagedefaultJSONResponse) VisitClearDosageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DosageRequestObject struct {
	Params DosageParams
}

type DosageResponseObject interface {
	VisitDosageResponse(w http.ResponseWriter) error
}

type Dosage200JSONResponse struct {
	// Dosage The user's current dosage schedule. This is null if the user has no dosage set.
	Dosage *Dosage `json:"dosage,omitempty"`

	// History The user's dosage history within the requested time range. If either historyStart or historyEnd are not provided, this will be null.
	History *DosageHistory `json:"history,omitempty"`
}

func (response Dosage200JSONResponse) VisitDosageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SetDosageRequestObject struct {
	Body *SetDosageJSONRequestBody
}

type SetDosageResponseObject interface {
	VisitSetDosageResponse(w http.ResponseWriter) error
}

type SetDosage204Response struct {
}

func (response SetDosage204Response) VisitSetDosageResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SetDosagedefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response SetDosagedefaultJSONResponse) VisitSetDosageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ForgetDosesRequestObject struct {
	Params ForgetDosesParams
}

type ForgetDosesResponseObject interface {
	VisitForgetDosesResponse(w http.ResponseWriter) error
}

type ForgetDoses204Response struct {
}

func (response ForgetDoses204Response) VisitForgetDosesResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ForgetDosesdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response ForgetDosesdefaultJSONResponse) VisitForgetDosesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RecordDoseRequestObject struct {
	Body *RecordDoseJSONRequestBody
}

type RecordDoseResponseObject interface {
	VisitRecordDoseResponse(w http.ResponseWriter) error
}

type RecordDose200JSONResponse DosageObservation

func (response RecordDose200JSONResponse) VisitRecordDoseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type EditDoseRequestObject struct {
	Body *EditDoseJSONRequestBody
}

type EditDoseResponseObject interface {
	VisitEditDoseResponse(w http.ResponseWriter) error
}

type EditDose204Response struct {
}

func (response EditDose204Response) VisitEditDoseResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type EditDosedefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response EditDosedefaultJSONResponse) VisitEditDoseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CurrentUserRequestObject struct {
}

type CurrentUserResponseObject interface {
	VisitCurrentUserResponse(w http.ResponseWriter) error
}

type CurrentUser200JSONResponse User

func (response CurrentUser200JSONResponse) VisitCurrentUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CurrentUserdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response CurrentUserdefaultJSONResponse) VisitCurrentUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CurrentUserAvatarRequestObject struct {
}

type CurrentUserAvatarResponseObject interface {
	VisitCurrentUserAvatarResponse(w http.ResponseWriter) error
}

type CurrentUserAvatar200ImageResponse struct {
	Body          io.Reader
	ContentType   string
	ContentLength int64
}

func (response CurrentUserAvatar200ImageResponse) VisitCurrentUserAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", response.ContentType)
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CurrentUserAvatardefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response CurrentUserAvatardefaultJSONResponse) VisitCurrentUserAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type SetCurrentUserAvatarRequestObject struct {
	ContentType string
	Body        io.Reader
}

type SetCurrentUserAvatarResponseObject interface {
	VisitSetCurrentUserAvatarResponse(w http.ResponseWriter) error
}

type SetCurrentUserAvatar204Response struct {
}

func (response SetCurrentUserAvatar204Response) VisitSetCurrentUserAvatarResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SetCurrentUserAvatardefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response SetCurrentUserAvatardefaultJSONResponse) VisitSetCurrentUserAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CurrentUserSecretRequestObject struct {
}

type CurrentUserSecretResponseObject interface {
	VisitCurrentUserSecretResponse(w http.ResponseWriter) error
}

type CurrentUserSecret200JSONResponse struct {
	// Secret A secret and unique user identifier. This secret is generated once and never changes. It is used to both authenticate and identify a user, so it should be kept secret.
	Secret UserSecret `json:"secret"`
}

func (response CurrentUserSecret200JSONResponse) VisitCurrentUserSecretResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CurrentUserSecretdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response CurrentUserSecretdefaultJSONResponse) VisitCurrentUserSecretResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteUserSessionRequestObject struct {
	Params DeleteUserSessionParams
}

type DeleteUserSessionResponseObject interface {
	VisitDeleteUserSessionResponse(w http.ResponseWriter) error
}

type DeleteUserSession204Response struct {
}

func (response DeleteUserSession204Response) VisitDeleteUserSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteUserSessiondefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response DeleteUserSessiondefaultJSONResponse) VisitDeleteUserSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CurrentUserSessionsRequestObject struct {
}

type CurrentUserSessionsResponseObject interface {
	VisitCurrentUserSessionsResponse(w http.ResponseWriter) error
}

type CurrentUserSessions200JSONResponse []Session

func (response CurrentUserSessions200JSONResponse) VisitCurrentUserSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CurrentUserSessionsdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response CurrentUserSessionsdefaultJSONResponse) VisitCurrentUserSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UserNotificationMethodsRequestObject struct {
}

type UserNotificationMethodsResponseObject interface {
	VisitUserNotificationMethodsResponse(w http.ResponseWriter) error
}

type UserNotificationMethods200JSONResponse ReturnedNotificationMethods

func (response UserNotificationMethods200JSONResponse) VisitUserNotificationMethodsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UserNotificationMethodsdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response UserNotificationMethodsdefaultJSONResponse) VisitUserNotificationMethodsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UserSubscribePushRequestObject struct {
	Body *UserSubscribePushJSONRequestBody
}

type UserSubscribePushResponseObject interface {
	VisitUserSubscribePushResponse(w http.ResponseWriter) error
}

type UserSubscribePush204Response struct {
}

func (response UserSubscribePush204Response) VisitUserSubscribePushResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UserSubscribePushdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response UserSubscribePushdefaultJSONResponse) VisitUserSubscribePushResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UserUnsubscribePushRequestObject struct {
	DeviceID PushDeviceID `json:"deviceID"`
}

type UserUnsubscribePushResponseObject interface {
	VisitUserUnsubscribePushResponse(w http.ResponseWriter) error
}

type UserUnsubscribePush204Response struct {
}

func (response UserUnsubscribePush204Response) VisitUserUnsubscribePushResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UserUnsubscribePushdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response UserUnsubscribePushdefaultJSONResponse) VisitUserUnsubscribePushResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UserPushSubscriptionRequestObject struct {
	DeviceID PushDeviceID `json:"deviceID"`
}

type UserPushSubscriptionResponseObject interface {
	VisitUserPushSubscriptionResponse(w http.ResponseWriter) error
}

type UserPushSubscription200JSONResponse PushSubscription

func (response UserPushSubscription200JSONResponse) VisitUserPushSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UserPushSubscription404JSONResponse Error

func (response UserPushSubscription404JSONResponse) VisitUserPushSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UserPushSubscriptiondefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response UserPushSubscriptiondefaultJSONResponse) VisitUserPushSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type WebPushInfoRequestObject struct {
}

type WebPushInfoResponseObject interface {
	VisitWebPushInfoResponse(w http.ResponseWriter) error
}

type WebPushInfo200JSONResponse PushInfo

func (response WebPushInfo200JSONResponse) VisitWebPushInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WebPushInfodefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response WebPushInfodefaultJSONResponse) VisitWebPushInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RegisterRequestObject struct {
	Body *RegisterJSONRequestBody
}

type RegisterResponseObject interface {
	VisitRegisterResponse(w http.ResponseWriter) error
}

type Register200JSONResponse struct {
	// Name The user's name
	Name string `json:"name"`

	// Locale A locale identifier.
	Locale Locale `json:"locale"`

	// HasAvatar Whether the user has an avatar.
	HasAvatar bool `json:"hasAvatar"`

	// Secret A secret and unique user identifier. This secret is generated once and never changes. It is used to both authenticate and identify a user, so it should be kept secret.
	Secret UserSecret `json:"secret"`
}

func (response Register200JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RegisterdefaultJSONResponse struct {
	Body       Error
	StatusCode int
}

func (response RegisterdefaultJSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Authenticate a user and obtain a session
	// (POST /auth)
	Auth(ctx context.Context, request AuthRequestObject) (AuthResponseObject, error)
	// List all available delivery methods
	// (GET /deliverymethods)
	DeliveryMethods(ctx context.Context, request DeliveryMethodsRequestObject) (DeliveryMethodsResponseObject, error)
	// Clear the user's dosage schedule
	// (DELETE /dosage)
	ClearDosage(ctx context.Context, request ClearDosageRequestObject) (ClearDosageResponseObject, error)
	// Get the user's dosage and optionally their history
	// (GET /dosage)
	Dosage(ctx context.Context, request DosageRequestObject) (DosageResponseObject, error)
	// Set the user's dosage
	// (PUT /dosage)
	SetDosage(ctx context.Context, request SetDosageRequestObject) (SetDosageResponseObject, error)
	// Delete multiple dosages from the user's history
	// (DELETE /dosage/dose)
	ForgetDoses(ctx context.Context, request ForgetDosesRequestObject) (ForgetDosesResponseObject, error)
	// Record a new dosage to the user's history
	// (POST /dosage/dose)
	RecordDose(ctx context.Context, request RecordDoseRequestObject) (RecordDoseResponseObject, error)
	// Update a dosage in the user's history
	// (PUT /dosage/dose)
	EditDose(ctx context.Context, request EditDoseRequestObject) (EditDoseResponseObject, error)
	// Get the current user
	// (GET /me)
	CurrentUser(ctx context.Context, request CurrentUserRequestObject) (CurrentUserResponseObject, error)
	// Get the current user's avatar
	// (GET /me/avatar)
	CurrentUserAvatar(ctx context.Context, request CurrentUserAvatarRequestObject) (CurrentUserAvatarResponseObject, error)
	// Set the current user's avatar
	// (PUT /me/avatar)
	SetCurrentUserAvatar(ctx context.Context, request SetCurrentUserAvatarRequestObject) (SetCurrentUserAvatarResponseObject, error)
	// Get the current user's secret
	// (GET /me/secret)
	CurrentUserSecret(ctx context.Context, request CurrentUserSecretRequestObject) (CurrentUserSecretResponseObject, error)
	// Delete one of the current user's sessions
	// (DELETE /me/sessions)
	DeleteUserSession(ctx context.Context, request DeleteUserSessionRequestObject) (DeleteUserSessionResponseObject, error)
	// List the current user's sessions
	// (GET /me/sessions)
	CurrentUserSessions(ctx context.Context, request CurrentUserSessionsRequestObject) (CurrentUserSessionsResponseObject, error)
	// Get the user's notification methods
	// (GET /notifications/methods)
	UserNotificationMethods(ctx context.Context, request UserNotificationMethodsRequestObject) (UserNotificationMethodsResponseObject, error)
	// Create or update a push subscription
	// (PUT /notifications/methods/push)
	UserSubscribePush(ctx context.Context, request UserSubscribePushRequestObject) (UserSubscribePushResponseObject, error)
	// Unsubscribe from push notifications
	// (DELETE /notifications/methods/push/{deviceID})
	UserUnsubscribePush(ctx context.Context, request UserUnsubscribePushRequestObject) (UserUnsubscribePushResponseObject, error)
	// Get the user's push notification subscription
	// (GET /notifications/methods/push/{deviceID})
	UserPushSubscription(ctx context.Context, request UserPushSubscriptionRequestObject) (UserPushSubscriptionResponseObject, error)
	// Get the server's push notification information
	// (GET /pushinfo)
	WebPushInfo(ctx context.Context, request WebPushInfoRequestObject) (WebPushInfoResponseObject, error)
	// Register a new account
	// (POST /register)
	Register(ctx context.Context, request RegisterRequestObject) (RegisterResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// Auth operation middleware
func (sh *strictHandler) Auth(w http.ResponseWriter, r *http.Request, params AuthParams) {
	var request AuthRequestObject

	request.Params = params

	var body AuthJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Auth(ctx, request.(AuthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Auth")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthResponseObject); ok {
		if err := validResponse.VisitAuthResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeliveryMethods operation middleware
func (sh *strictHandler) DeliveryMethods(w http.ResponseWriter, r *http.Request) {
	var request DeliveryMethodsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeliveryMethods(ctx, request.(DeliveryMethodsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeliveryMethods")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeliveryMethodsResponseObject); ok {
		if err := validResponse.VisitDeliveryMethodsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ClearDosage operation middleware
func (sh *strictHandler) ClearDosage(w http.ResponseWriter, r *http.Request) {
	var request ClearDosageRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ClearDosage(ctx, request.(ClearDosageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ClearDosage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ClearDosageResponseObject); ok {
		if err := validResponse.VisitClearDosageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Dosage operation middleware
func (sh *strictHandler) Dosage(w http.ResponseWriter, r *http.Request, params DosageParams) {
	var request DosageRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Dosage(ctx, request.(DosageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Dosage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DosageResponseObject); ok {
		if err := validResponse.VisitDosageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SetDosage operation middleware
func (sh *strictHandler) SetDosage(w http.ResponseWriter, r *http.Request) {
	var request SetDosageRequestObject

	var body SetDosageJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SetDosage(ctx, request.(SetDosageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetDosage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SetDosageResponseObject); ok {
		if err := validResponse.VisitSetDosageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ForgetDoses operation middleware
func (sh *strictHandler) ForgetDoses(w http.ResponseWriter, r *http.Request, params ForgetDosesParams) {
	var request ForgetDosesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ForgetDoses(ctx, request.(ForgetDosesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ForgetDoses")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ForgetDosesResponseObject); ok {
		if err := validResponse.VisitForgetDosesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RecordDose operation middleware
func (sh *strictHandler) RecordDose(w http.ResponseWriter, r *http.Request) {
	var request RecordDoseRequestObject

	var body RecordDoseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RecordDose(ctx, request.(RecordDoseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RecordDose")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RecordDoseResponseObject); ok {
		if err := validResponse.VisitRecordDoseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EditDose operation middleware
func (sh *strictHandler) EditDose(w http.ResponseWriter, r *http.Request) {
	var request EditDoseRequestObject

	var body EditDoseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EditDose(ctx, request.(EditDoseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EditDose")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EditDoseResponseObject); ok {
		if err := validResponse.VisitEditDoseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CurrentUser operation middleware
func (sh *strictHandler) CurrentUser(w http.ResponseWriter, r *http.Request) {
	var request CurrentUserRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CurrentUser(ctx, request.(CurrentUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CurrentUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CurrentUserResponseObject); ok {
		if err := validResponse.VisitCurrentUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CurrentUserAvatar operation middleware
func (sh *strictHandler) CurrentUserAvatar(w http.ResponseWriter, r *http.Request) {
	var request CurrentUserAvatarRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CurrentUserAvatar(ctx, request.(CurrentUserAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CurrentUserAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CurrentUserAvatarResponseObject); ok {
		if err := validResponse.VisitCurrentUserAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SetCurrentUserAvatar operation middleware
func (sh *strictHandler) SetCurrentUserAvatar(w http.ResponseWriter, r *http.Request) {
	var request SetCurrentUserAvatarRequestObject

	request.ContentType = r.Header.Get("Content-Type")

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SetCurrentUserAvatar(ctx, request.(SetCurrentUserAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetCurrentUserAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SetCurrentUserAvatarResponseObject); ok {
		if err := validResponse.VisitSetCurrentUserAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CurrentUserSecret operation middleware
func (sh *strictHandler) CurrentUserSecret(w http.ResponseWriter, r *http.Request) {
	var request CurrentUserSecretRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CurrentUserSecret(ctx, request.(CurrentUserSecretRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CurrentUserSecret")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CurrentUserSecretResponseObject); ok {
		if err := validResponse.VisitCurrentUserSecretResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUserSession operation middleware
func (sh *strictHandler) DeleteUserSession(w http.ResponseWriter, r *http.Request, params DeleteUserSessionParams) {
	var request DeleteUserSessionRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUserSession(ctx, request.(DeleteUserSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUserSession")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserSessionResponseObject); ok {
		if err := validResponse.VisitDeleteUserSessionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CurrentUserSessions operation middleware
func (sh *strictHandler) CurrentUserSessions(w http.ResponseWriter, r *http.Request) {
	var request CurrentUserSessionsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CurrentUserSessions(ctx, request.(CurrentUserSessionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CurrentUserSessions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CurrentUserSessionsResponseObject); ok {
		if err := validResponse.VisitCurrentUserSessionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UserNotificationMethods operation middleware
func (sh *strictHandler) UserNotificationMethods(w http.ResponseWriter, r *http.Request) {
	var request UserNotificationMethodsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UserNotificationMethods(ctx, request.(UserNotificationMethodsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UserNotificationMethods")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UserNotificationMethodsResponseObject); ok {
		if err := validResponse.VisitUserNotificationMethodsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UserSubscribePush operation middleware
func (sh *strictHandler) UserSubscribePush(w http.ResponseWriter, r *http.Request) {
	var request UserSubscribePushRequestObject

	var body UserSubscribePushJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UserSubscribePush(ctx, request.(UserSubscribePushRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UserSubscribePush")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UserSubscribePushResponseObject); ok {
		if err := validResponse.VisitUserSubscribePushResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UserUnsubscribePush operation middleware
func (sh *strictHandler) UserUnsubscribePush(w http.ResponseWriter, r *http.Request, deviceID PushDeviceID) {
	var request UserUnsubscribePushRequestObject

	request.DeviceID = deviceID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UserUnsubscribePush(ctx, request.(UserUnsubscribePushRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UserUnsubscribePush")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UserUnsubscribePushResponseObject); ok {
		if err := validResponse.VisitUserUnsubscribePushResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UserPushSubscription operation middleware
func (sh *strictHandler) UserPushSubscription(w http.ResponseWriter, r *http.Request, deviceID PushDeviceID) {
	var request UserPushSubscriptionRequestObject

	request.DeviceID = deviceID

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UserPushSubscription(ctx, request.(UserPushSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UserPushSubscription")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UserPushSubscriptionResponseObject); ok {
		if err := validResponse.VisitUserPushSubscriptionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WebPushInfo operation middleware
func (sh *strictHandler) WebPushInfo(w http.ResponseWriter, r *http.Request) {
	var request WebPushInfoRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WebPushInfo(ctx, request.(WebPushInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WebPushInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WebPushInfoResponseObject); ok {
		if err := validResponse.VisitWebPushInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Register operation middleware
func (sh *strictHandler) Register(w http.ResponseWriter, r *http.Request) {
	var request RegisterRequestObject

	var body RegisterJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Register(ctx, request.(RegisterRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Register")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RegisterResponseObject); ok {
		if err := validResponse.VisitRegisterResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+Zjm3ArZrXH/Trf/CQAA//8ue+16IEQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
