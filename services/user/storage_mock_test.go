// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"io"
	"libdb.so/e2clicker/internal/asset"
	"sync"
)

// Ensure, that UserStorageMock does implement UserStorage.
// If this is not the case, regenerate this file with moq.
var _ UserStorage = &UserStorageMock{}

// UserStorageMock is a mock implementation of UserStorage.
//
//	func TestSomethingThatUsesUserStorage(t *testing.T) {
//
//		// make and configure a mocked UserStorage
//		mockedUserStorage := &UserStorageMock{
//			CreateUserFunc: func(ctx context.Context, id UserID, email string, passhash []byte, name string) (User, error) {
//				panic("mock out the CreateUser method")
//			},
//			UpdateUserEmailPasswordFunc: func(ctx context.Context, id UserID, email string, passhash []byte) error {
//				panic("mock out the UpdateUserEmailPassword method")
//			},
//			UpdateUserLocaleFunc: func(ctx context.Context, id UserID, locale Locale) error {
//				panic("mock out the UpdateUserLocale method")
//			},
//			UpdateUserNameFunc: func(ctx context.Context, id UserID, name string) error {
//				panic("mock out the UpdateUserName method")
//			},
//			UserFunc: func(ctx context.Context, id UserID) (User, error) {
//				panic("mock out the User method")
//			},
//			UserPasswordFromEmailFunc: func(ctx context.Context, email string) (UserPassword, error) {
//				panic("mock out the UserPasswordFromEmail method")
//			},
//		}
//
//		// use mockedUserStorage in code that requires UserStorage
//		// and then make assertions.
//
//	}
type UserStorageMock struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, id UserID, email string, passhash []byte, name string) (User, error)

	// UpdateUserEmailPasswordFunc mocks the UpdateUserEmailPassword method.
	UpdateUserEmailPasswordFunc func(ctx context.Context, id UserID, email string, passhash []byte) error

	// UpdateUserLocaleFunc mocks the UpdateUserLocale method.
	UpdateUserLocaleFunc func(ctx context.Context, id UserID, locale Locale) error

	// UpdateUserNameFunc mocks the UpdateUserName method.
	UpdateUserNameFunc func(ctx context.Context, id UserID, name string) error

	// UserFunc mocks the User method.
	UserFunc func(ctx context.Context, id UserID) (User, error)

	// UserPasswordFromEmailFunc mocks the UserPasswordFromEmail method.
	UserPasswordFromEmailFunc func(ctx context.Context, email string) (UserPassword, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// Email is the email argument value.
			Email string
			// Passhash is the passhash argument value.
			Passhash []byte
			// Name is the name argument value.
			Name string
		}
		// UpdateUserEmailPassword holds details about calls to the UpdateUserEmailPassword method.
		UpdateUserEmailPassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// Email is the email argument value.
			Email string
			// Passhash is the passhash argument value.
			Passhash []byte
		}
		// UpdateUserLocale holds details about calls to the UpdateUserLocale method.
		UpdateUserLocale []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// Locale is the locale argument value.
			Locale Locale
		}
		// UpdateUserName holds details about calls to the UpdateUserName method.
		UpdateUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// Name is the name argument value.
			Name string
		}
		// User holds details about calls to the User method.
		User []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
		}
		// UserPasswordFromEmail holds details about calls to the UserPasswordFromEmail method.
		UserPasswordFromEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
	}
	lockCreateUser              sync.RWMutex
	lockUpdateUserEmailPassword sync.RWMutex
	lockUpdateUserLocale        sync.RWMutex
	lockUpdateUserName          sync.RWMutex
	lockUser                    sync.RWMutex
	lockUserPasswordFromEmail   sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *UserStorageMock) CreateUser(ctx context.Context, id UserID, email string, passhash []byte, name string) (User, error) {
	callInfo := struct {
		Ctx      context.Context
		ID       UserID
		Email    string
		Passhash []byte
		Name     string
	}{
		Ctx:      ctx,
		ID:       id,
		Email:    email,
		Passhash: passhash,
		Name:     name,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	if mock.CreateUserFunc == nil {
		var (
			userOut User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.CreateUserFunc(ctx, id, email, passhash, name)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedUserStorage.CreateUserCalls())
func (mock *UserStorageMock) CreateUserCalls() []struct {
	Ctx      context.Context
	ID       UserID
	Email    string
	Passhash []byte
	Name     string
} {
	var calls []struct {
		Ctx      context.Context
		ID       UserID
		Email    string
		Passhash []byte
		Name     string
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// UpdateUserEmailPassword calls UpdateUserEmailPasswordFunc.
func (mock *UserStorageMock) UpdateUserEmailPassword(ctx context.Context, id UserID, email string, passhash []byte) error {
	callInfo := struct {
		Ctx      context.Context
		ID       UserID
		Email    string
		Passhash []byte
	}{
		Ctx:      ctx,
		ID:       id,
		Email:    email,
		Passhash: passhash,
	}
	mock.lockUpdateUserEmailPassword.Lock()
	mock.calls.UpdateUserEmailPassword = append(mock.calls.UpdateUserEmailPassword, callInfo)
	mock.lockUpdateUserEmailPassword.Unlock()
	if mock.UpdateUserEmailPasswordFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserEmailPasswordFunc(ctx, id, email, passhash)
}

// UpdateUserEmailPasswordCalls gets all the calls that were made to UpdateUserEmailPassword.
// Check the length with:
//
//	len(mockedUserStorage.UpdateUserEmailPasswordCalls())
func (mock *UserStorageMock) UpdateUserEmailPasswordCalls() []struct {
	Ctx      context.Context
	ID       UserID
	Email    string
	Passhash []byte
} {
	var calls []struct {
		Ctx      context.Context
		ID       UserID
		Email    string
		Passhash []byte
	}
	mock.lockUpdateUserEmailPassword.RLock()
	calls = mock.calls.UpdateUserEmailPassword
	mock.lockUpdateUserEmailPassword.RUnlock()
	return calls
}

// UpdateUserLocale calls UpdateUserLocaleFunc.
func (mock *UserStorageMock) UpdateUserLocale(ctx context.Context, id UserID, locale Locale) error {
	callInfo := struct {
		Ctx    context.Context
		ID     UserID
		Locale Locale
	}{
		Ctx:    ctx,
		ID:     id,
		Locale: locale,
	}
	mock.lockUpdateUserLocale.Lock()
	mock.calls.UpdateUserLocale = append(mock.calls.UpdateUserLocale, callInfo)
	mock.lockUpdateUserLocale.Unlock()
	if mock.UpdateUserLocaleFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserLocaleFunc(ctx, id, locale)
}

// UpdateUserLocaleCalls gets all the calls that were made to UpdateUserLocale.
// Check the length with:
//
//	len(mockedUserStorage.UpdateUserLocaleCalls())
func (mock *UserStorageMock) UpdateUserLocaleCalls() []struct {
	Ctx    context.Context
	ID     UserID
	Locale Locale
} {
	var calls []struct {
		Ctx    context.Context
		ID     UserID
		Locale Locale
	}
	mock.lockUpdateUserLocale.RLock()
	calls = mock.calls.UpdateUserLocale
	mock.lockUpdateUserLocale.RUnlock()
	return calls
}

// UpdateUserName calls UpdateUserNameFunc.
func (mock *UserStorageMock) UpdateUserName(ctx context.Context, id UserID, name string) error {
	callInfo := struct {
		Ctx  context.Context
		ID   UserID
		Name string
	}{
		Ctx:  ctx,
		ID:   id,
		Name: name,
	}
	mock.lockUpdateUserName.Lock()
	mock.calls.UpdateUserName = append(mock.calls.UpdateUserName, callInfo)
	mock.lockUpdateUserName.Unlock()
	if mock.UpdateUserNameFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserNameFunc(ctx, id, name)
}

// UpdateUserNameCalls gets all the calls that were made to UpdateUserName.
// Check the length with:
//
//	len(mockedUserStorage.UpdateUserNameCalls())
func (mock *UserStorageMock) UpdateUserNameCalls() []struct {
	Ctx  context.Context
	ID   UserID
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		ID   UserID
		Name string
	}
	mock.lockUpdateUserName.RLock()
	calls = mock.calls.UpdateUserName
	mock.lockUpdateUserName.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *UserStorageMock) User(ctx context.Context, id UserID) (User, error) {
	callInfo := struct {
		Ctx context.Context
		ID  UserID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	if mock.UserFunc == nil {
		var (
			userOut User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.UserFunc(ctx, id)
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedUserStorage.UserCalls())
func (mock *UserStorageMock) UserCalls() []struct {
	Ctx context.Context
	ID  UserID
} {
	var calls []struct {
		Ctx context.Context
		ID  UserID
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// UserPasswordFromEmail calls UserPasswordFromEmailFunc.
func (mock *UserStorageMock) UserPasswordFromEmail(ctx context.Context, email string) (UserPassword, error) {
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockUserPasswordFromEmail.Lock()
	mock.calls.UserPasswordFromEmail = append(mock.calls.UserPasswordFromEmail, callInfo)
	mock.lockUserPasswordFromEmail.Unlock()
	if mock.UserPasswordFromEmailFunc == nil {
		var (
			userPasswordOut UserPassword
			errOut          error
		)
		return userPasswordOut, errOut
	}
	return mock.UserPasswordFromEmailFunc(ctx, email)
}

// UserPasswordFromEmailCalls gets all the calls that were made to UserPasswordFromEmail.
// Check the length with:
//
//	len(mockedUserStorage.UserPasswordFromEmailCalls())
func (mock *UserStorageMock) UserPasswordFromEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockUserPasswordFromEmail.RLock()
	calls = mock.calls.UserPasswordFromEmail
	mock.lockUserPasswordFromEmail.RUnlock()
	return calls
}

// Ensure, that UserAvatarStorageMock does implement UserAvatarStorage.
// If this is not the case, regenerate this file with moq.
var _ UserAvatarStorage = &UserAvatarStorageMock{}

// UserAvatarStorageMock is a mock implementation of UserAvatarStorage.
//
//	func TestSomethingThatUsesUserAvatarStorage(t *testing.T) {
//
//		// make and configure a mocked UserAvatarStorage
//		mockedUserAvatarStorage := &UserAvatarStorageMock{
//			SetUserAvatarFunc: func(ctx context.Context, id UserID, a asset.Asset[io.Reader]) error {
//				panic("mock out the SetUserAvatar method")
//			},
//			UserAvatarFunc: func(ctx context.Context, id UserID) (asset.Asset[io.ReadCloser], error) {
//				panic("mock out the UserAvatar method")
//			},
//		}
//
//		// use mockedUserAvatarStorage in code that requires UserAvatarStorage
//		// and then make assertions.
//
//	}
type UserAvatarStorageMock struct {
	// SetUserAvatarFunc mocks the SetUserAvatar method.
	SetUserAvatarFunc func(ctx context.Context, id UserID, a asset.Asset[io.Reader]) error

	// UserAvatarFunc mocks the UserAvatar method.
	UserAvatarFunc func(ctx context.Context, id UserID) (asset.Asset[io.ReadCloser], error)

	// calls tracks calls to the methods.
	calls struct {
		// SetUserAvatar holds details about calls to the SetUserAvatar method.
		SetUserAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// A is the a argument value.
			A asset.Asset[io.Reader]
		}
		// UserAvatar holds details about calls to the UserAvatar method.
		UserAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
		}
	}
	lockSetUserAvatar sync.RWMutex
	lockUserAvatar    sync.RWMutex
}

// SetUserAvatar calls SetUserAvatarFunc.
func (mock *UserAvatarStorageMock) SetUserAvatar(ctx context.Context, id UserID, a asset.Asset[io.Reader]) error {
	callInfo := struct {
		Ctx context.Context
		ID  UserID
		A   asset.Asset[io.Reader]
	}{
		Ctx: ctx,
		ID:  id,
		A:   a,
	}
	mock.lockSetUserAvatar.Lock()
	mock.calls.SetUserAvatar = append(mock.calls.SetUserAvatar, callInfo)
	mock.lockSetUserAvatar.Unlock()
	if mock.SetUserAvatarFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetUserAvatarFunc(ctx, id, a)
}

// SetUserAvatarCalls gets all the calls that were made to SetUserAvatar.
// Check the length with:
//
//	len(mockedUserAvatarStorage.SetUserAvatarCalls())
func (mock *UserAvatarStorageMock) SetUserAvatarCalls() []struct {
	Ctx context.Context
	ID  UserID
	A   asset.Asset[io.Reader]
} {
	var calls []struct {
		Ctx context.Context
		ID  UserID
		A   asset.Asset[io.Reader]
	}
	mock.lockSetUserAvatar.RLock()
	calls = mock.calls.SetUserAvatar
	mock.lockSetUserAvatar.RUnlock()
	return calls
}

// UserAvatar calls UserAvatarFunc.
func (mock *UserAvatarStorageMock) UserAvatar(ctx context.Context, id UserID) (asset.Asset[io.ReadCloser], error) {
	callInfo := struct {
		Ctx context.Context
		ID  UserID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockUserAvatar.Lock()
	mock.calls.UserAvatar = append(mock.calls.UserAvatar, callInfo)
	mock.lockUserAvatar.Unlock()
	if mock.UserAvatarFunc == nil {
		var (
			assetOut asset.Asset[io.ReadCloser]
			errOut   error
		)
		return assetOut, errOut
	}
	return mock.UserAvatarFunc(ctx, id)
}

// UserAvatarCalls gets all the calls that were made to UserAvatar.
// Check the length with:
//
//	len(mockedUserAvatarStorage.UserAvatarCalls())
func (mock *UserAvatarStorageMock) UserAvatarCalls() []struct {
	Ctx context.Context
	ID  UserID
} {
	var calls []struct {
		Ctx context.Context
		ID  UserID
	}
	mock.lockUserAvatar.RLock()
	calls = mock.calls.UserAvatar
	mock.lockUserAvatar.RUnlock()
	return calls
}

// Ensure, that UserSessionStorageMock does implement UserSessionStorage.
// If this is not the case, regenerate this file with moq.
var _ UserSessionStorage = &UserSessionStorageMock{}

// UserSessionStorageMock is a mock implementation of UserSessionStorage.
//
//	func TestSomethingThatUsesUserSessionStorage(t *testing.T) {
//
//		// make and configure a mocked UserSessionStorage
//		mockedUserSessionStorage := &UserSessionStorageMock{
//			RegisterSessionFunc: func(ctx context.Context, id UserID, token []byte, userAgent string) error {
//				panic("mock out the RegisterSession method")
//			},
//			ValidateSessionFunc: func(ctx context.Context, token []byte) (User, error) {
//				panic("mock out the ValidateSession method")
//			},
//		}
//
//		// use mockedUserSessionStorage in code that requires UserSessionStorage
//		// and then make assertions.
//
//	}
type UserSessionStorageMock struct {
	// RegisterSessionFunc mocks the RegisterSession method.
	RegisterSessionFunc func(ctx context.Context, id UserID, token []byte, userAgent string) error

	// ValidateSessionFunc mocks the ValidateSession method.
	ValidateSessionFunc func(ctx context.Context, token []byte) (User, error)

	// calls tracks calls to the methods.
	calls struct {
		// RegisterSession holds details about calls to the RegisterSession method.
		RegisterSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID UserID
			// Token is the token argument value.
			Token []byte
			// UserAgent is the userAgent argument value.
			UserAgent string
		}
		// ValidateSession holds details about calls to the ValidateSession method.
		ValidateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token []byte
		}
	}
	lockRegisterSession sync.RWMutex
	lockValidateSession sync.RWMutex
}

// RegisterSession calls RegisterSessionFunc.
func (mock *UserSessionStorageMock) RegisterSession(ctx context.Context, id UserID, token []byte, userAgent string) error {
	callInfo := struct {
		Ctx       context.Context
		ID        UserID
		Token     []byte
		UserAgent string
	}{
		Ctx:       ctx,
		ID:        id,
		Token:     token,
		UserAgent: userAgent,
	}
	mock.lockRegisterSession.Lock()
	mock.calls.RegisterSession = append(mock.calls.RegisterSession, callInfo)
	mock.lockRegisterSession.Unlock()
	if mock.RegisterSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RegisterSessionFunc(ctx, id, token, userAgent)
}

// RegisterSessionCalls gets all the calls that were made to RegisterSession.
// Check the length with:
//
//	len(mockedUserSessionStorage.RegisterSessionCalls())
func (mock *UserSessionStorageMock) RegisterSessionCalls() []struct {
	Ctx       context.Context
	ID        UserID
	Token     []byte
	UserAgent string
} {
	var calls []struct {
		Ctx       context.Context
		ID        UserID
		Token     []byte
		UserAgent string
	}
	mock.lockRegisterSession.RLock()
	calls = mock.calls.RegisterSession
	mock.lockRegisterSession.RUnlock()
	return calls
}

// ValidateSession calls ValidateSessionFunc.
func (mock *UserSessionStorageMock) ValidateSession(ctx context.Context, token []byte) (User, error) {
	callInfo := struct {
		Ctx   context.Context
		Token []byte
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockValidateSession.Lock()
	mock.calls.ValidateSession = append(mock.calls.ValidateSession, callInfo)
	mock.lockValidateSession.Unlock()
	if mock.ValidateSessionFunc == nil {
		var (
			userOut User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.ValidateSessionFunc(ctx, token)
}

// ValidateSessionCalls gets all the calls that were made to ValidateSession.
// Check the length with:
//
//	len(mockedUserSessionStorage.ValidateSessionCalls())
func (mock *UserSessionStorageMock) ValidateSessionCalls() []struct {
	Ctx   context.Context
	Token []byte
} {
	var calls []struct {
		Ctx   context.Context
		Token []byte
	}
	mock.lockValidateSession.RLock()
	calls = mock.calls.ValidateSession
	mock.lockValidateSession.RUnlock()
	return calls
}
