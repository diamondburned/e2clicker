// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"libdb.so/e2clicker/internal/asset"
	"sync"
)

// Ensure, that UserStorageMock does implement UserStorage.
// If this is not the case, regenerate this file with moq.
var _ UserStorage = &UserStorageMock{}

// UserStorageMock is a mock implementation of UserStorage.
//
//	func TestSomethingThatUsesUserStorage(t *testing.T) {
//
//		// make and configure a mocked UserStorage
//		mockedUserStorage := &UserStorageMock{
//			CreateUserFunc: func(ctx context.Context, secret Secret, name string) (User, error) {
//				panic("mock out the CreateUser method")
//			},
//			UpdateUserLocaleFunc: func(ctx context.Context, secret Secret, locale Locale) error {
//				panic("mock out the UpdateUserLocale method")
//			},
//			UpdateUserNameFunc: func(ctx context.Context, secret Secret, name string) error {
//				panic("mock out the UpdateUserName method")
//			},
//			UserFunc: func(ctx context.Context, secret Secret) (User, error) {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedUserStorage in code that requires UserStorage
//		// and then make assertions.
//
//	}
type UserStorageMock struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, secret Secret, name string) (User, error)

	// UpdateUserLocaleFunc mocks the UpdateUserLocale method.
	UpdateUserLocaleFunc func(ctx context.Context, secret Secret, locale Locale) error

	// UpdateUserNameFunc mocks the UpdateUserName method.
	UpdateUserNameFunc func(ctx context.Context, secret Secret, name string) error

	// UserFunc mocks the User method.
	UserFunc func(ctx context.Context, secret Secret) (User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
			// Name is the name argument value.
			Name string
		}
		// UpdateUserLocale holds details about calls to the UpdateUserLocale method.
		UpdateUserLocale []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
			// Locale is the locale argument value.
			Locale Locale
		}
		// UpdateUserName holds details about calls to the UpdateUserName method.
		UpdateUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
			// Name is the name argument value.
			Name string
		}
		// User holds details about calls to the User method.
		User []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
		}
	}
	lockCreateUser       sync.RWMutex
	lockUpdateUserLocale sync.RWMutex
	lockUpdateUserName   sync.RWMutex
	lockUser             sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *UserStorageMock) CreateUser(ctx context.Context, secret Secret, name string) (User, error) {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
		Name   string
	}{
		Ctx:    ctx,
		Secret: secret,
		Name:   name,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	if mock.CreateUserFunc == nil {
		var (
			userOut User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.CreateUserFunc(ctx, secret, name)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedUserStorage.CreateUserCalls())
func (mock *UserStorageMock) CreateUserCalls() []struct {
	Ctx    context.Context
	Secret Secret
	Name   string
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
		Name   string
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// UpdateUserLocale calls UpdateUserLocaleFunc.
func (mock *UserStorageMock) UpdateUserLocale(ctx context.Context, secret Secret, locale Locale) error {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
		Locale Locale
	}{
		Ctx:    ctx,
		Secret: secret,
		Locale: locale,
	}
	mock.lockUpdateUserLocale.Lock()
	mock.calls.UpdateUserLocale = append(mock.calls.UpdateUserLocale, callInfo)
	mock.lockUpdateUserLocale.Unlock()
	if mock.UpdateUserLocaleFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserLocaleFunc(ctx, secret, locale)
}

// UpdateUserLocaleCalls gets all the calls that were made to UpdateUserLocale.
// Check the length with:
//
//	len(mockedUserStorage.UpdateUserLocaleCalls())
func (mock *UserStorageMock) UpdateUserLocaleCalls() []struct {
	Ctx    context.Context
	Secret Secret
	Locale Locale
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
		Locale Locale
	}
	mock.lockUpdateUserLocale.RLock()
	calls = mock.calls.UpdateUserLocale
	mock.lockUpdateUserLocale.RUnlock()
	return calls
}

// UpdateUserName calls UpdateUserNameFunc.
func (mock *UserStorageMock) UpdateUserName(ctx context.Context, secret Secret, name string) error {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
		Name   string
	}{
		Ctx:    ctx,
		Secret: secret,
		Name:   name,
	}
	mock.lockUpdateUserName.Lock()
	mock.calls.UpdateUserName = append(mock.calls.UpdateUserName, callInfo)
	mock.lockUpdateUserName.Unlock()
	if mock.UpdateUserNameFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserNameFunc(ctx, secret, name)
}

// UpdateUserNameCalls gets all the calls that were made to UpdateUserName.
// Check the length with:
//
//	len(mockedUserStorage.UpdateUserNameCalls())
func (mock *UserStorageMock) UpdateUserNameCalls() []struct {
	Ctx    context.Context
	Secret Secret
	Name   string
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
		Name   string
	}
	mock.lockUpdateUserName.RLock()
	calls = mock.calls.UpdateUserName
	mock.lockUpdateUserName.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *UserStorageMock) User(ctx context.Context, secret Secret) (User, error) {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
	}{
		Ctx:    ctx,
		Secret: secret,
	}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	if mock.UserFunc == nil {
		var (
			userOut User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.UserFunc(ctx, secret)
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedUserStorage.UserCalls())
func (mock *UserStorageMock) UserCalls() []struct {
	Ctx    context.Context
	Secret Secret
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Ensure, that UserAvatarStorageMock does implement UserAvatarStorage.
// If this is not the case, regenerate this file with moq.
var _ UserAvatarStorage = &UserAvatarStorageMock{}

// UserAvatarStorageMock is a mock implementation of UserAvatarStorage.
//
//	func TestSomethingThatUsesUserAvatarStorage(t *testing.T) {
//
//		// make and configure a mocked UserAvatarStorage
//		mockedUserAvatarStorage := &UserAvatarStorageMock{
//			SetUserAvatarFunc: func(ctx context.Context, secret Secret, a asset.Reader) error {
//				panic("mock out the SetUserAvatar method")
//			},
//			UserAvatarFunc: func(ctx context.Context, secret Secret) (asset.ReadCloser, error) {
//				panic("mock out the UserAvatar method")
//			},
//		}
//
//		// use mockedUserAvatarStorage in code that requires UserAvatarStorage
//		// and then make assertions.
//
//	}
type UserAvatarStorageMock struct {
	// SetUserAvatarFunc mocks the SetUserAvatar method.
	SetUserAvatarFunc func(ctx context.Context, secret Secret, a asset.Reader) error

	// UserAvatarFunc mocks the UserAvatar method.
	UserAvatarFunc func(ctx context.Context, secret Secret) (asset.ReadCloser, error)

	// calls tracks calls to the methods.
	calls struct {
		// SetUserAvatar holds details about calls to the SetUserAvatar method.
		SetUserAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
			// A is the a argument value.
			A asset.Reader
		}
		// UserAvatar holds details about calls to the UserAvatar method.
		UserAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Secret is the secret argument value.
			Secret Secret
		}
	}
	lockSetUserAvatar sync.RWMutex
	lockUserAvatar    sync.RWMutex
}

// SetUserAvatar calls SetUserAvatarFunc.
func (mock *UserAvatarStorageMock) SetUserAvatar(ctx context.Context, secret Secret, a asset.Reader) error {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
		A      asset.Reader
	}{
		Ctx:    ctx,
		Secret: secret,
		A:      a,
	}
	mock.lockSetUserAvatar.Lock()
	mock.calls.SetUserAvatar = append(mock.calls.SetUserAvatar, callInfo)
	mock.lockSetUserAvatar.Unlock()
	if mock.SetUserAvatarFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetUserAvatarFunc(ctx, secret, a)
}

// SetUserAvatarCalls gets all the calls that were made to SetUserAvatar.
// Check the length with:
//
//	len(mockedUserAvatarStorage.SetUserAvatarCalls())
func (mock *UserAvatarStorageMock) SetUserAvatarCalls() []struct {
	Ctx    context.Context
	Secret Secret
	A      asset.Reader
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
		A      asset.Reader
	}
	mock.lockSetUserAvatar.RLock()
	calls = mock.calls.SetUserAvatar
	mock.lockSetUserAvatar.RUnlock()
	return calls
}

// UserAvatar calls UserAvatarFunc.
func (mock *UserAvatarStorageMock) UserAvatar(ctx context.Context, secret Secret) (asset.ReadCloser, error) {
	callInfo := struct {
		Ctx    context.Context
		Secret Secret
	}{
		Ctx:    ctx,
		Secret: secret,
	}
	mock.lockUserAvatar.Lock()
	mock.calls.UserAvatar = append(mock.calls.UserAvatar, callInfo)
	mock.lockUserAvatar.Unlock()
	if mock.UserAvatarFunc == nil {
		var (
			vOut   asset.ReadCloser
			errOut error
		)
		return vOut, errOut
	}
	return mock.UserAvatarFunc(ctx, secret)
}

// UserAvatarCalls gets all the calls that were made to UserAvatar.
// Check the length with:
//
//	len(mockedUserAvatarStorage.UserAvatarCalls())
func (mock *UserAvatarStorageMock) UserAvatarCalls() []struct {
	Ctx    context.Context
	Secret Secret
} {
	var calls []struct {
		Ctx    context.Context
		Secret Secret
	}
	mock.lockUserAvatar.RLock()
	calls = mock.calls.UserAvatar
	mock.lockUserAvatar.RUnlock()
	return calls
}

// Ensure, that UserSessionStorageMock does implement UserSessionStorage.
// If this is not the case, regenerate this file with moq.
var _ UserSessionStorage = &UserSessionStorageMock{}

// UserSessionStorageMock is a mock implementation of UserSessionStorage.
//
//	func TestSomethingThatUsesUserSessionStorage(t *testing.T) {
//
//		// make and configure a mocked UserSessionStorage
//		mockedUserSessionStorage := &UserSessionStorageMock{
//			DeleteSessionFunc: func(ctx context.Context, userSecret Secret, sessionID int64) error {
//				panic("mock out the DeleteSession method")
//			},
//			ListSessionsFunc: func(ctx context.Context, userSecret Secret) ([]Session, error) {
//				panic("mock out the ListSessions method")
//			},
//			RegisterSessionFunc: func(ctx context.Context, token []byte, userSecret Secret, userAgent string) error {
//				panic("mock out the RegisterSession method")
//			},
//			ValidateSessionFunc: func(ctx context.Context, token []byte) (Session, error) {
//				panic("mock out the ValidateSession method")
//			},
//		}
//
//		// use mockedUserSessionStorage in code that requires UserSessionStorage
//		// and then make assertions.
//
//	}
type UserSessionStorageMock struct {
	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, userSecret Secret, sessionID int64) error

	// ListSessionsFunc mocks the ListSessions method.
	ListSessionsFunc func(ctx context.Context, userSecret Secret) ([]Session, error)

	// RegisterSessionFunc mocks the RegisterSession method.
	RegisterSessionFunc func(ctx context.Context, token []byte, userSecret Secret, userAgent string) error

	// ValidateSessionFunc mocks the ValidateSession method.
	ValidateSessionFunc func(ctx context.Context, token []byte) (Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserSecret is the userSecret argument value.
			UserSecret Secret
			// SessionID is the sessionID argument value.
			SessionID int64
		}
		// ListSessions holds details about calls to the ListSessions method.
		ListSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserSecret is the userSecret argument value.
			UserSecret Secret
		}
		// RegisterSession holds details about calls to the RegisterSession method.
		RegisterSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token []byte
			// UserSecret is the userSecret argument value.
			UserSecret Secret
			// UserAgent is the userAgent argument value.
			UserAgent string
		}
		// ValidateSession holds details about calls to the ValidateSession method.
		ValidateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token []byte
		}
	}
	lockDeleteSession   sync.RWMutex
	lockListSessions    sync.RWMutex
	lockRegisterSession sync.RWMutex
	lockValidateSession sync.RWMutex
}

// DeleteSession calls DeleteSessionFunc.
func (mock *UserSessionStorageMock) DeleteSession(ctx context.Context, userSecret Secret, sessionID int64) error {
	callInfo := struct {
		Ctx        context.Context
		UserSecret Secret
		SessionID  int64
	}{
		Ctx:        ctx,
		UserSecret: userSecret,
		SessionID:  sessionID,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	if mock.DeleteSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteSessionFunc(ctx, userSecret, sessionID)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedUserSessionStorage.DeleteSessionCalls())
func (mock *UserSessionStorageMock) DeleteSessionCalls() []struct {
	Ctx        context.Context
	UserSecret Secret
	SessionID  int64
} {
	var calls []struct {
		Ctx        context.Context
		UserSecret Secret
		SessionID  int64
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// ListSessions calls ListSessionsFunc.
func (mock *UserSessionStorageMock) ListSessions(ctx context.Context, userSecret Secret) ([]Session, error) {
	callInfo := struct {
		Ctx        context.Context
		UserSecret Secret
	}{
		Ctx:        ctx,
		UserSecret: userSecret,
	}
	mock.lockListSessions.Lock()
	mock.calls.ListSessions = append(mock.calls.ListSessions, callInfo)
	mock.lockListSessions.Unlock()
	if mock.ListSessionsFunc == nil {
		var (
			sessionsOut []Session
			errOut      error
		)
		return sessionsOut, errOut
	}
	return mock.ListSessionsFunc(ctx, userSecret)
}

// ListSessionsCalls gets all the calls that were made to ListSessions.
// Check the length with:
//
//	len(mockedUserSessionStorage.ListSessionsCalls())
func (mock *UserSessionStorageMock) ListSessionsCalls() []struct {
	Ctx        context.Context
	UserSecret Secret
} {
	var calls []struct {
		Ctx        context.Context
		UserSecret Secret
	}
	mock.lockListSessions.RLock()
	calls = mock.calls.ListSessions
	mock.lockListSessions.RUnlock()
	return calls
}

// RegisterSession calls RegisterSessionFunc.
func (mock *UserSessionStorageMock) RegisterSession(ctx context.Context, token []byte, userSecret Secret, userAgent string) error {
	callInfo := struct {
		Ctx        context.Context
		Token      []byte
		UserSecret Secret
		UserAgent  string
	}{
		Ctx:        ctx,
		Token:      token,
		UserSecret: userSecret,
		UserAgent:  userAgent,
	}
	mock.lockRegisterSession.Lock()
	mock.calls.RegisterSession = append(mock.calls.RegisterSession, callInfo)
	mock.lockRegisterSession.Unlock()
	if mock.RegisterSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RegisterSessionFunc(ctx, token, userSecret, userAgent)
}

// RegisterSessionCalls gets all the calls that were made to RegisterSession.
// Check the length with:
//
//	len(mockedUserSessionStorage.RegisterSessionCalls())
func (mock *UserSessionStorageMock) RegisterSessionCalls() []struct {
	Ctx        context.Context
	Token      []byte
	UserSecret Secret
	UserAgent  string
} {
	var calls []struct {
		Ctx        context.Context
		Token      []byte
		UserSecret Secret
		UserAgent  string
	}
	mock.lockRegisterSession.RLock()
	calls = mock.calls.RegisterSession
	mock.lockRegisterSession.RUnlock()
	return calls
}

// ValidateSession calls ValidateSessionFunc.
func (mock *UserSessionStorageMock) ValidateSession(ctx context.Context, token []byte) (Session, error) {
	callInfo := struct {
		Ctx   context.Context
		Token []byte
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockValidateSession.Lock()
	mock.calls.ValidateSession = append(mock.calls.ValidateSession, callInfo)
	mock.lockValidateSession.Unlock()
	if mock.ValidateSessionFunc == nil {
		var (
			sessionOut Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.ValidateSessionFunc(ctx, token)
}

// ValidateSessionCalls gets all the calls that were made to ValidateSession.
// Check the length with:
//
//	len(mockedUserSessionStorage.ValidateSessionCalls())
func (mock *UserSessionStorageMock) ValidateSessionCalls() []struct {
	Ctx   context.Context
	Token []byte
} {
	var calls []struct {
		Ctx   context.Context
		Token []byte
	}
	mock.lockValidateSession.RLock()
	calls = mock.calls.ValidateSession
	mock.lockValidateSession.RUnlock()
	return calls
}
