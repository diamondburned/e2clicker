// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	xid "github.com/rs/xid"
	notification "libdb.so/hrtclicker/v2/services/notification"
)

const createUser = `-- name: CreateUser :exec
/*
 * User
 */
INSERT INTO users (user_id, email, passhash, name)
  VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	UserID   xid.ID
	Email    string
	Passhash []byte
	Name     string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.UserID,
		arg.Email,
		arg.Passhash,
		arg.Name,
	)
	return err
}

const deliveryMethod = `-- name: DeliveryMethod :one
SELECT id, units, name
FROM delivery_methods
WHERE name = $1
`

func (q *Queries) DeliveryMethod(ctx context.Context, name string) (DeliveryMethod, error) {
	row := q.db.QueryRow(ctx, deliveryMethod, name)
	var i DeliveryMethod
	err := row.Scan(&i.ID, &i.Units, &i.Name)
	return i, err
}

const deliveryMethods = `-- name: DeliveryMethods :many
/*
 * Delivery Method
 */
SELECT id, units, name
FROM delivery_methods
`

func (q *Queries) DeliveryMethods(ctx context.Context) ([]DeliveryMethod, error) {
	rows, err := q.db.Query(ctx, deliveryMethods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryMethod
	for rows.Next() {
		var i DeliveryMethod
		if err := rows.Scan(&i.ID, &i.Units, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerSession = `-- name: RegisterSession :exec
INSERT INTO user_sessions (user_id, token, created_at, last_used, user_agent)
  VALUES ($1, $2, now(), now(), $3)
`

type RegisterSessionParams struct {
	UserID    xid.ID
	Token     []byte
	UserAgent pgtype.Text
}

func (q *Queries) RegisterSession(ctx context.Context, arg RegisterSessionParams) error {
	_, err := q.db.Exec(ctx, registerSession, arg.UserID, arg.Token, arg.UserAgent)
	return err
}

const userAddDosage = `-- name: UserAddDosage :exec
INSERT INTO dosage_history (user_id, last_dose, taken_at, delivery_method, dose) (
  SELECT $1, $2, now(), delivery_method, dose
  FROM dosage_schedule
  WHERE user_id = $1)
`

type UserAddDosageParams struct {
	UserID   pgtype.Uint32
	LastDose pgtype.Int8
}

func (q *Queries) UserAddDosage(ctx context.Context, arg UserAddDosageParams) error {
	_, err := q.db.Exec(ctx, userAddDosage, arg.UserID, arg.LastDose)
	return err
}

const userAvatar = `-- name: UserAvatar :one
SELECT avatar_image
FROM user_avatars
WHERE user_id = $1
`

func (q *Queries) UserAvatar(ctx context.Context, userID xid.ID) ([]byte, error) {
	row := q.db.QueryRow(ctx, userAvatar, userID)
	var avatar_image []byte
	err := row.Scan(&avatar_image)
	return avatar_image, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT user_id, email, name, EXISTS (
    SELECT user_id
    FROM user_avatars
    WHERE user_id = users.user_id) AS has_avatar
FROM users
WHERE email = $1
`

type UserByEmailRow struct {
	UserID    xid.ID
	Email     string
	Name      string
	HasAvatar bool
}

func (q *Queries) UserByEmail(ctx context.Context, email string) (UserByEmailRow, error) {
	row := q.db.QueryRow(ctx, userByEmail, email)
	var i UserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.HasAvatar,
	)
	return i, err
}

const userByID = `-- name: UserByID :one
SELECT user_id, email, name, EXISTS (
    SELECT user_id
    FROM user_avatars
    WHERE user_id = users.user_id) AS has_avatar
FROM users
WHERE users.user_id = $1
`

type UserByIDRow struct {
	UserID    xid.ID
	Email     string
	Name      string
	HasAvatar bool
}

func (q *Queries) UserByID(ctx context.Context, userID xid.ID) (UserByIDRow, error) {
	row := q.db.QueryRow(ctx, userByID, userID)
	var i UserByIDRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.HasAvatar,
	)
	return i, err
}

const userConfigureNotifications = `-- name: UserConfigureNotifications :exec
UPDATE
  users
SET notification_service = $2
WHERE user_id = $1
`

type UserConfigureNotificationsParams struct {
	UserID              xid.ID
	NotificationService notification.NotificationConfigJSON
}

func (q *Queries) UserConfigureNotifications(ctx context.Context, arg UserConfigureNotificationsParams) error {
	_, err := q.db.Exec(ctx, userConfigureNotifications, arg.UserID, arg.NotificationService)
	return err
}

const userDosageHistory = `-- name: UserDosageHistory :many
SELECT dose_id, last_dose, user_id, delivery_method, dose, taken_at, taken_off_at
FROM dosage_history
WHERE user_id = $1
  AND taken_at >= $2
ORDER BY dose_id DESC
LIMIT $3
`

type UserDosageHistoryParams struct {
	UserID  pgtype.Uint32
	TakenAt pgtype.Timestamptz
	Limit   int32
}

func (q *Queries) UserDosageHistory(ctx context.Context, arg UserDosageHistoryParams) ([]DosageHistory, error) {
	rows, err := q.db.Query(ctx, userDosageHistory, arg.UserID, arg.TakenAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DosageHistory
	for rows.Next() {
		var i DosageHistory
		if err := rows.Scan(
			&i.DoseID,
			&i.LastDose,
			&i.UserID,
			&i.DeliveryMethod,
			&i.Dose,
			&i.TakenAt,
			&i.TakenOffAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userDosageSchedule = `-- name: UserDosageSchedule :exec
/*
 * Dosage and dosage-related
 */
SELECT user_id, delivery_method, dose, interval, concurrence
FROM dosage_schedule
WHERE user_id = $1
`

func (q *Queries) UserDosageSchedule(ctx context.Context, userID xid.ID) error {
	_, err := q.db.Exec(ctx, userDosageSchedule, userID)
	return err
}

const userSetAvatar = `-- name: UserSetAvatar :exec
INSERT INTO user_avatars (user_id, avatar_image)
  VALUES ($1, $2)
ON CONFLICT (user_id)
  DO UPDATE SET
    avatar_image = $2
`

type UserSetAvatarParams struct {
	UserID      xid.ID
	AvatarImage []byte
}

func (q *Queries) UserSetAvatar(ctx context.Context, arg UserSetAvatarParams) error {
	_, err := q.db.Exec(ctx, userSetAvatar, arg.UserID, arg.AvatarImage)
	return err
}

const userSetNotificationMessage = `-- name: UserSetNotificationMessage :exec
UPDATE
  users
SET notification_message = $2
WHERE user_id = $1
`

type UserSetNotificationMessageParams struct {
	UserID              xid.ID
	NotificationMessage pgtype.Text
}

func (q *Queries) UserSetNotificationMessage(ctx context.Context, arg UserSetNotificationMessageParams) error {
	_, err := q.db.Exec(ctx, userSetNotificationMessage, arg.UserID, arg.NotificationMessage)
	return err
}

const userUpdateDosageSchedule = `-- name: UserUpdateDosageSchedule :exec
INSERT INTO dosage_schedule (user_id, delivery_method, dose, interval, concurrence)
  VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (user_id)
  DO UPDATE SET
    delivery_method = $2, dose = $3, interval = $4, concurrence = $5
`

type UserUpdateDosageScheduleParams struct {
	UserID         xid.ID
	DeliveryMethod pgtype.Text
	Dose           pgtype.Numeric
	Interval       pgtype.Interval
	Concurrence    pgtype.Numeric
}

func (q *Queries) UserUpdateDosageSchedule(ctx context.Context, arg UserUpdateDosageScheduleParams) error {
	_, err := q.db.Exec(ctx, userUpdateDosageSchedule,
		arg.UserID,
		arg.DeliveryMethod,
		arg.Dose,
		arg.Interval,
		arg.Concurrence,
	)
	return err
}

const userUpdateEmailPassword = `-- name: UserUpdateEmailPassword :exec
UPDATE
  users
SET email = $2, passhash = $3
WHERE user_id = $1
`

type UserUpdateEmailPasswordParams struct {
	UserID   xid.ID
	Email    string
	Passhash []byte
}

func (q *Queries) UserUpdateEmailPassword(ctx context.Context, arg UserUpdateEmailPasswordParams) error {
	_, err := q.db.Exec(ctx, userUpdateEmailPassword, arg.UserID, arg.Email, arg.Passhash)
	return err
}

const userUpdateName = `-- name: UserUpdateName :exec
UPDATE
  users
SET name = $2
WHERE user_id = $1
`

type UserUpdateNameParams struct {
	UserID xid.ID
	Name   string
}

func (q *Queries) UserUpdateName(ctx context.Context, arg UserUpdateNameParams) error {
	_, err := q.db.Exec(ctx, userUpdateName, arg.UserID, arg.Name)
	return err
}

const userValidateSession = `-- name: UserValidateSession :one
UPDATE
  user_sessions
SET last_used = now()
FROM users
WHERE user_sessions.user_id = users.user_id
  AND token = $1
  AND last_used > now() - '7 days'::interval
RETURNING users.user_id, users.email, users.name, EXISTS (
    SELECT user_id
    FROM user_avatars
    WHERE user_id = users.user_id) AS has_avatar
`

type UserValidateSessionRow struct {
	UserID    xid.ID
	Email     string
	Name      string
	HasAvatar bool
}

func (q *Queries) UserValidateSession(ctx context.Context, token []byte) (UserValidateSessionRow, error) {
	row := q.db.QueryRow(ctx, userValidateSession, token)
	var i UserValidateSessionRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.HasAvatar,
	)
	return i, err
}
