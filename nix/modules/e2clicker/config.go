// Code generated by nixmod2go. DO NOT EDIT.
package e2clickermodule

import (
	"encoding/json"
	"errors"
)

// BackendConfig is the struct type for `config`.
type BackendConfig struct {
	// Enable: whether to enable e2clicker backend.
	Enable  bool   `json:"enable"`
	Package string `json:"package"`
	// API: configuration for the API server.
	API API `json:"api"`
	// Debug: enable debug logging and other debug features.
	Debug bool `json:"debug"`
	// LogFormat: format of the log output.
	LogFormat LogFormat `json:"logFormat"`
	// Notification: configuration for the notification service.
	Notification Notification `json:"notification"`
	// PostgreSQL: configuration for the PostgreSQL database.
	PostgreSQL PostgreSQL `json:"postgresql"`
}

// PostgreSQL is the struct type for `config.postgresql`.
type PostgreSQL struct {
	// DatabaseURI: URI of the database to use.
	DatabaseURI string `json:"databaseURI"`
}

// Notification is the struct type for `config.notification`.
type Notification struct {
	// ClientTimeout: HTTP timeout when making requests to notification servers.
	ClientTimeout string `json:"clientTimeout"`
	// Email: path to the file containing the email configuration in JSON.
	// See `secrets/email-config.example.json` for an example.
	Email *EmailJSON `json:"email"`
	// WebPush: web push notification configuration. This contains the
	// VAPID keys that are used to encrypt the notifications. Use `just
	// generate-vapid` to generate the keys.
	WebPush *WebPushJSON `json:"webPush"`
}

// SMTP is the struct type for `config.notification.email.smtp`.
type SMTP struct {
	Auth Auth `json:"auth"`
	// Host: SMTP server host.
	Host string `json:"host"`
	// Port: SMTP server port.
	Port int `json:"port"`
	// Secure: whether to use a secure connection.
	Secure bool `json:"secure"`
}

// Auth is the struct type for `config.notification.email.smtp.auth`.
type Auth struct {
	// Password: SMTP server password.
	Password string `json:"password"`
	// Username: SMTP server username.
	Username string `json:"username"`
}

// API is the struct type for `config.api`.
type API struct {
	// DebugRequests: enable debug logging for requests.
	DebugRequests bool `json:"debugRequests"`
	// ListenAddress address the API server should listen on.
	ListenAddress string `json:"listenAddress"`
}

// LogFormat is the enum type for `config.logFormat`.
type LogFormat string

const (
	LogFormatColor LogFormat = "color"
	LogFormatJSON  LogFormat = "json"
	LogFormatText  LogFormat = "text"
)

// Email describes the `either` type for `config.notification.email`.
type Email interface {
	isEmail()
}

// EmailPath is one of the types that satisfy [Email].
type EmailPath string

// EmailSubmodule is one of the types that satisfy [Email].
type EmailSubmodule struct {
	// From: email address to send notifications from.
	From string `json:"from"`
	// SMTP: SMTP server configuration.
	SMTP SMTP `json:"smtp"`
}

func (e EmailPath) isEmail() {
}
func (e EmailSubmodule) isEmail() {
}

// NewEmailPath constructs a value of type `path` that satisfies [Email].
func NewEmailPath(e string) Email {
	return EmailPath(e)
}

// NewEmailSubmodule constructs a value of type `submodule` that satisfies [Email].
func NewEmailSubmodule(e struct {
	// From: email address to send notifications from.
	From string `json:"from"`
	// SMTP: SMTP server configuration.
	SMTP SMTP `json:"smtp"`
}) Email {
	return EmailSubmodule(e)
}

// EmailJSON wraps [Email] and implements the json.Unmarshaler interface.
type EmailJSON struct{ Value Email }

// UnmarshalJSON implements the [json.Unmarshaler] interface for [Email].
func (e *EmailJSON) UnmarshalJSON(data []byte) error {
	_v, err := unmarshalEmail(data)
	if err != nil {
		return err
	}
	e.Value = _v
	return nil
}

// MarshalJSON implements the [json.Marshaler] interface for [Email].
func (e EmailJSON) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.Value)
}

func unmarshalEmail(data json.RawMessage) (Email, error) {

	var v0 string
	if err := json.Unmarshal(data, &v0); err == nil {
		return EmailPath(v0), nil
	}

	var v1 struct {
		// From: email address to send notifications from.
		From string `json:"from"`
		// SMTP: SMTP server configuration.
		SMTP SMTP `json:"smtp"`
	}
	if err := json.Unmarshal(data, &v1); err == nil {
		return EmailSubmodule(v1), nil
	}

	return nil, errors.New("failed to unmarshal Email: unknown type received")
}

// WebPush describes the `either` type for `config.notification.webPush`.
type WebPush interface {
	isWebPush()
}

// WebPushPath is one of the types that satisfy [WebPush].
type WebPushPath string

// WebPushSubmodule is one of the types that satisfy [WebPush].
type WebPushSubmodule struct {
	// PrivateKey: VAPID private key.
	PrivateKey string `json:"privateKey"`
	// PublicKey: VAPID public key.
	PublicKey string `json:"publicKey"`
}

func (w WebPushPath) isWebPush() {
}
func (w WebPushSubmodule) isWebPush() {
}

// NewWebPushPath constructs a value of type `path` that satisfies [WebPush].
func NewWebPushPath(w string) WebPush {
	return WebPushPath(w)
}

// NewWebPushSubmodule constructs a value of type `submodule` that satisfies [WebPush].
func NewWebPushSubmodule(w struct {
	// PrivateKey: VAPID private key.
	PrivateKey string `json:"privateKey"`
	// PublicKey: VAPID public key.
	PublicKey string `json:"publicKey"`
}) WebPush {
	return WebPushSubmodule(w)
}

// WebPushJSON wraps [WebPush] and implements the json.Unmarshaler interface.
type WebPushJSON struct{ Value WebPush }

// UnmarshalJSON implements the [json.Unmarshaler] interface for [WebPush].
func (w *WebPushJSON) UnmarshalJSON(data []byte) error {
	_v, err := unmarshalWebPush(data)
	if err != nil {
		return err
	}
	w.Value = _v
	return nil
}

// MarshalJSON implements the [json.Marshaler] interface for [WebPush].
func (w WebPushJSON) MarshalJSON() ([]byte, error) {
	return json.Marshal(w.Value)
}

func unmarshalWebPush(data json.RawMessage) (WebPush, error) {

	var v0 string
	if err := json.Unmarshal(data, &v0); err == nil {
		return WebPushPath(v0), nil
	}

	var v1 struct {
		// PrivateKey: VAPID private key.
		PrivateKey string `json:"privateKey"`
		// PublicKey: VAPID public key.
		PublicKey string `json:"publicKey"`
	}
	if err := json.Unmarshal(data, &v1); err == nil {
		return WebPushSubmodule(v1), nil
	}

	return nil, errors.New("failed to unmarshal WebPush: unknown type received")
}
