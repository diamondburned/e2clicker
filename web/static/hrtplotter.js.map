{
  "version": 3,
  "sources": ["hrtplotter/plot.ts", "hrtplotter/predict.ts", "hrtplotter/patch-values.json", "hrtplotter/predictors.ts"],
  "sourcesContent": ["import { type TimeValue } from \"./predict.ts\";\n\n// @deno-types=\"https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/typings.d.ts\"\nimport * as charts from \"https://cdn.jsdelivr.net/npm/lightweight-charts@4.1/dist/lightweight-charts.standalone.production.mjs\";\n\nconst styles = globalThis.getComputedStyle(document.body);\nconst colors = {\n  muted: styles.getPropertyValue(\"--b2\"),\n  primary: styles.getPropertyValue(\"--pink\"),\n};\n\nexport class EstrogenPlotter {\n  chart: charts.IChartApi;\n  series: charts.ISeriesApi<\"Line\", charts.Time>;\n\n  constructor(\n    readonly element: HTMLElement,\n  ) {\n    this.chart = charts.createChart(this.element, {\n      autoSize: true,\n      handleScale: false,\n      handleScroll: false,\n      grid: {\n        vertLines: { visible: false },\n        horzLines: { visible: true, color: colors.muted },\n      },\n      layout: {\n        background: { type: charts.ColorType.Solid, color: \"transparent\" },\n        textColor: styles.color,\n        fontFamily: styles.fontFamily,\n      },\n      rightPriceScale: {\n        scaleMargins: {\n          top: 0,\n          bottom: 0,\n        },\n      },\n      timeScale: {\n        lockVisibleTimeRangeOnResize: true,\n        borderVisible: false,\n        timeVisible: true,\n        secondsVisible: false,\n        fixLeftEdge: true,\n        fixRightEdge: true,\n      },\n    });\n\n    if (!this.chart.autoSizeActive()) {\n      alert(\"Chart is not auto-sizing. It will not work right.\");\n    }\n\n    this.series = this.chart.addLineSeries({\n      color: colors.primary,\n      priceFormat: {\n        type: \"custom\",\n        formatter: (price: charts.BarPrice) => price.toFixed(0) + \" pg/mL\",\n      },\n      baseLineVisible: false,\n      priceLineVisible: true,\n      pointMarkersVisible: false,\n      crosshairMarkerVisible: false,\n      autoscaleInfoProvider: (autoscale: () => charts.AutoscaleInfo) => {\n        const scale = autoscale();\n        if (scale != null) {\n          scale.priceRange.minValue = 0;\n          scale.priceRange.maxValue *= 1.1;\n        }\n        return scale;\n      },\n    });\n  }\n\n  update(values: TimeValue[]) {\n    this.series.setData(\n      values.map((t) => ({\n        time: t.t as charts.UTCTimestamp,\n        value: t.v,\n      })),\n    );\n    console.log(values);\n    this.chart.timeScale().fitContent();\n  }\n}\n", "// Timestamp is the Unix time in seconds.\nexport type Timestamp = number;\n\n// TimeValue is a pair of a timestamp and a value.\nexport type TimeValue = {\n  t: Timestamp;\n  v: number;\n};\n\nexport const averageDays = [1, 7, 14, 30] as const;\n\nexport function calculateAverages(\n  values: TimeValue[],\n): Record<typeof averageDays[number], number[]> {\n  const averages = {};\n  for (const days of averageDays) {\n    const averageHours = days * 24;\n    averages[days] = values\n      .slice(-averageHours)\n      .map((v) => v.v)\n      .reduce((a, b) => a + b, 0) / averageHours;\n  }\n  return averages as Record<typeof averageDays[number], number[]>;\n}\n\nexport type PredictOpts = {\n  // intervalHours is the expected interval between applications in hours.\n  intervalHours: number;\n  // concurrence is the number of applications that are concurrently active; for\n  // patches, this is the normal number of patches on the skin at any point in\n  // time.\n  concurrence: number;\n  // hoursAgo is the number of hours ago to start predicting from.\n  hoursAgo: number;\n};\n\nexport interface Predictor {\n  // predict predicts the estrogen levels over time for the given application\n  // times.\n  predict(applicationTimes: Timestamp[], opts: PredictOpts): Promise<TimeValue[]>;\n}\n\nconst HOUR = 3600;\n\n// DiscreteHourlyPredictor is a Predictor that predicts the levels using a\n// discrete list of values. It specifically only supports hourly values and will\n// return hourly values.\nexport class DiscreteHourlyPredictor implements Predictor {\n  f: (t: number) => number;\n  f_0: number; // start hour\n  f_1: number; // end hour\n\n  constructor(\n    hourlyValues: number[],\n    scale: number,\n  ) {\n    this.f = (t: number) => (hourlyValues[t] ?? 0) * scale;\n    this.f_0 = 0;\n    this.f_1 = hourlyValues.length;\n  }\n\n  predict(applicationTimes: Timestamp[], opts: PredictOpts): Promise<TimeValue[]> {\n    if (applicationTimes.length === 0) {\n      return Promise.resolve([]);\n    }\n    applicationTimes.sort((a, b) => a - b);\n\n    const f_0 = this.f_0;\n    const f_1 = this.f_1;\n    // f_1short specifically is the f_1 value but limited to the concurrence\n    // value. This value will only be used for patches older than the last few\n    // current patches.\n    const f_1short = opts.concurrence > 0\n      ? Math.min(this.f_1, opts.intervalHours * opts.concurrence)\n      : this.f_1;\n    console.debug(`predictor:`, { f_0, f_1, f_1short });\n\n    const now = Date.now() / 1000;\n    const prior = now - opts.hoursAgo * HOUR;\n    console.debug(\n      `predictor: from`,\n      new Date(prior * 1000).toISOString(),\n      `to`,\n      new Date(now * 1000).toISOString(),\n    );\n\n    const hours = Math.ceil((now - prior) / HOUR);\n    console.debug(`predictor: hours`, hours);\n\n    const values = Array<number>(hours).fill(0);\n    console.debug(\"values\", values);\n\n    for (const [i, t] of applicationTimes.entries()) {\n      // Calculate the hourly index for the current application time by\n      // subtracting it with the first time and rounding it.\n      let hourStart = Math.floor((t - prior) / HOUR) + f_0;\n      let hourEnd = hourStart + (\n        // If the patch index is near the end, then we should use f_1, else we\n        // use f_1short.\n        applicationTimes.length - i <= opts.concurrence ? f_1 : f_1short\n      );\n      console.debug(\"for\", t, \"going from\", hourStart, \"to\", hourEnd, \"of\", values.length, \"hours\");\n\n      if (hourEnd < 0) {\n        // The entire interval is before the start of the prediction\n        // period, so we ignore it.\n        continue;\n      }\n\n      hourStart = Math.max(0, hourStart);\n      hourEnd = Math.min(values.length, hourEnd);\n\n      console.debug(\"for\", t, \"total hours taken is\", hourEnd - hourStart);\n      for (let h = hourStart; h < hourEnd; h++) {\n        values[h] += this.f(h - hourStart);\n      }\n    }\n\n    console.debug(\"values\", values);\n\n    const timeValues = values.map((value, i) => ({ t: prior + (i * HOUR), v: value }));\n    return Promise.resolve(timeValues);\n  }\n}\n", "[\n  0,\n  8.5,\n  17,\n  25.5,\n  34,\n  47.7,\n  59.6,\n  71.4,\n  83.3,\n  88.6,\n  93.8,\n  99,\n  102.7,\n  103.2,\n  103.8,\n  104.3,\n  104.8,\n  105.3,\n  105.9,\n  106.4,\n  106.9,\n  107.4,\n  108,\n  108.5,\n  108.1,\n  108.1,\n  108.1,\n  108.1,\n  108.1,\n  108.1,\n  109.2,\n  110.3,\n  111.4,\n  112.5,\n  113.6,\n  114.7,\n  114.4,\n  111.9,\n  109.4,\n  106.9,\n  104.4,\n  101.9,\n  99.4,\n  96.9,\n  94.4,\n  91.9,\n  89.4,\n  86.9,\n  84.9,\n  84.4,\n  84,\n  83.6,\n  83.2,\n  82.8,\n  82.4,\n  81.9,\n  81.5,\n  81.1,\n  80.7,\n  80.3,\n  79.9,\n  78.3,\n  76.8,\n  75.3,\n  73.7,\n  72.2,\n  70.7,\n  69.2,\n  67.6,\n  66.1,\n  64.6,\n  63.1,\n  61.5,\n  61.4,\n  61.3,\n  61.1,\n  61,\n  60.8,\n  60.7,\n  60.6,\n  60.4,\n  60.3,\n  60.1,\n  60,\n  59.9,\n  59.4,\n  59,\n  58.6,\n  58.2,\n  57.8,\n  57.4,\n  56.9,\n  56.5,\n  56.1,\n  55.7,\n  55.3,\n  54.9,\n  54.4,\n  54,\n  53.6,\n  53.2,\n  52.8,\n  52.4,\n  51.9,\n  51.5,\n  51.1,\n  50.7,\n  50.3,\n  49.9,\n  49.4,\n  49,\n  48.6,\n  48.2,\n  47.8,\n  47.4,\n  46.9,\n  46.5,\n  46.1,\n  45.7,\n  45.3,\n  44.9,\n  44.4,\n  44,\n  43.6,\n  43.2,\n  42.8,\n  42.4,\n  41.9,\n  41.5,\n  41.1,\n  40.7,\n  40.3,\n  39.9,\n  39.4,\n  39,\n  38.6,\n  38.2,\n  37.8,\n  37.4,\n  36.9,\n  36.5,\n  36.1,\n  35.7,\n  35.3,\n  34.9,\n  34.4,\n  34,\n  33.6,\n  33.2,\n  32.8,\n  32.4,\n  31.9,\n  31.5,\n  31.1,\n  30.7,\n  30.3,\n  29.9,\n  29.4,\n  29,\n  28.6,\n  28.2,\n  27.8,\n  27.4,\n  26.9,\n  26.5,\n  26.1,\n  25.7,\n  25.3,\n  24.9\n]\n", "import { DiscreteHourlyPredictor } from \"./predict.ts\";\nimport patchValues_ from \"./patch-values.json\" with { type: \"json\" };\n\nconst patchValues = patchValues_ as number[];\n// const patchMaxValue = Math.max(...patchValues);\n// const patchTestedValue = 272.0; // hard-coded to its own lab-tested estrogen levels\n// const patchScale = patchTestedValue / patchMaxValue;\n//\n// console.debug(\n//   \"predictor: using\",\n//   patchTestedValue,\n//   \"as the baseline level for scaling a maximum of\",\n//   patchMaxValue,\n//   \"meaning we'll scale the values by\",\n//   patchScale,\n// );\n\nconst patchScale = 1.0;\n\nexport const patchesPredictor = new DiscreteHourlyPredictor(\n  patchValues,\n  patchScale,\n);\n"],
  "mappings": "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AAS,EACjCC,EAAU,KAAK,IAAItB,EAAO,OAAQsB,CAAO,EAEzC,QAAQ,MAAM,MAAOX,EAAG,uBAAwBW,EAAUD,CAAS,EACnE,QAASE,EAAIF,EAAWE,EAAID,EAASC,IACnCvB,EAAOuB,CAAC,GAAK,KAAK,EAAEA,EAAIF,CAAS,EAErC,CAEA,QAAQ,MAAM,SAAUrB,CAAM,EAE9B,IAAMwB,EAAaxB,EAAO,IAAI,CAACyB,EAAOL,KAAO,CAAE,EAAGF,EAASE,EAAIb,EAAO,EAAGkB,CAAM,EAAE,EACjF,OAAO,QAAQ,QAAQD,CAAU,CACnC,CACF,EC3HA,IAAAE,EAAA,CACE,EACA,IACA,GACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,IACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACF,ECvKA,IAAMC,EAAcC,EAcdC,EAAa,EAENC,EAAmB,IAAIC,EAClCJ,EACAE,CACF",
  "names": ["charts", "styles", "colors", "EstrogenPlotter", "element", "price", "autoscale", "scale", "values", "t", "averageDays", "calculateAverages", "values", "averages", "days", "averageHours", "v", "a", "b", "HOUR", "DiscreteHourlyPredictor", "hourlyValues", "scale", "t", "applicationTimes", "opts", "f_0", "f_1", "f_1short", "now", "prior", "hours", "i", "hourStart", "hourEnd", "h", "timeValues", "value", "patch_values_default", "patchValues", "patch_values_default", "patchScale", "patchesPredictor", "DiscreteHourlyPredictor"]
}
